package * cmd/internal/ld
package src/cmd/ld/* cmd/internal/ld
package src/liblink/* cmd/internal/ld
package include/* cmd/internal/ld
package src/cmd/5l/* cmd/new5l
package src/cmd/6l/* cmd/new6l
package src/cmd/8l/* cmd/new8l
package src/cmd/9l/* cmd/new9l

slice LSym.r LSym.nr LSym.maxr
slice LSym.p LSym.np LSym.maxp

func Symgrow(ctxt *Link, s *LSym, siz int64) {
	if int64(int(siz)) != siz {
		log.Fatalf("symgrow size %d too long", siz)
	}
	if int64(len(s.P)) >= siz {
		return
	}
	for cap(s.P) < int(siz) {
		s.P = append(s.P[:len(s.P)], 0)
	}
	s.P = s.P[:siz]
}

func Addrel(s *LSym) *Reloc {
	s.R = append(s.R, Reloc{})
	return &s.R[len(s.R)-1]
}

func setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
	if s.Type == 0 {
		s.Type = SDATA
	}
	s.Reachable = true
	if s.Size < off+wid {
		s.Size = off + wid
		Symgrow(ctxt, s, s.Size)
	}

	switch wid {
	case 1:
		s.P[off] = uint8(v)
	case 2:
		ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(v))
	case 4:
		ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(v))
	case 8:
		ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(v))
	}
	
	return off+wid
}

diff {
type LinkArch struct {
+	ByteOrder	binary.ByteOrder
}
diff {
amd64 = LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
amd64p32 = LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
arm = LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
386 = LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
ppc64 = LinkArch{
+	ByteOrder: binary.BigEndian,
}
diff {
ppc64le = LinkArch{
+	ByteOrder: binary.LittleEndian,
}

delete Biobuf

diff {
-			cast = []byte(&i16)
-			for i = 0; i < 2; i++ {
-				s.P[off+i] = cast[inuxi2[i]]
-			}
+			Ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(i16))
}

diff {
-			cast = []byte(&fl)
-			for i = 0; i < 4; i++ {
-				s.P[off+i] = cast[Inuxi4[i]]
-			}
+			Ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(fl))
}

diff {
-			cast = []byte(&o)
-			for i = 0; i < 8; i++ {
-				s.P[off+i] = cast[inuxi8[i]]
-			}
+			Ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(o))
}

diff {
-	main.Memmove(s.P[r:], str, n)
+	copy(s.P[r:], str)
+	s.P[int(r)+len(str)] = 0
}

func decode_inuxi(p []byte, sz int) uint64 {
	switch sz {
	case 2:
		return uint64(Ctxt.Arch.ByteOrder.Uint16(p))
	case 4:
		return uint64(Ctxt.Arch.ByteOrder.Uint32(p))
	case 8:
		return Ctxt.Arch.ByteOrder.Uint64(p)
	}
	Diag("dwarf: decode inuxi %d", sz)
	Errorexit()
	return 0
}

diff {
-func uleb128enc(v uint64, dst string) int {
+func uleb128enc(v uint64, dst []byte) int {
}

diff {
-		if dst != "" {
+		if dst != nil {
			dst[0] = byte(c)
			dst = dst[1:]
}

diff {
-func sleb128enc(v int64, dst string) int {
+func sleb128enc(v int64, dst []byte) int {
}

func uleb128put(v int64) {
	var buf[10]byte
	n := uleb128enc(uint64(v), buf[:])
	Cwrite(buf[:n])
}

func sleb128put(v int64) {
	var buf[10]byte
	n := sleb128enc(v, buf[:])
	Cwrite(buf[:n])
}

slice putattrs.af

func newmemberoffsetattr(die *DWDie, offs int32) {
	var block [20]byte
	var i int

	i = 0
	block[i] = DW_OP_plus_uconst
	i++
	i += uleb128enc(uint64(offs), block[i:])
	newattr(die, DW_AT_data_member_location, DW_CLS_BLOCK, int64(i), block[:i])
}

diff {
func newcfaoffsetattr(die *DWDie, offs int32) {
-	var block string
+	var block [20]byte
}

diff {
-	newattr(die, DW_AT_location, DW_CLS_BLOCK, int64(i), make([]byte, i))
-	main.Memmove(die.attr.data, block, i)
+	newattr(die, DW_AT_location, DW_CLS_BLOCK, int64(i), block[:i])
}

diff {
-		make([]byte, main.Strlen(ptrname)+1) = ptrname
-		die = newdie(&dwtypes, DW_ABRV_PTRTYPE, make([]byte, main.Strlen(ptrname)+1))
+		die = newdie(&dwtypes, DW_ABRV_PTRTYPE, ptrname)
}

diff {
-	n = string(make([]byte, main.Strlen(buf)+1))
-	main.Memmove(n, buf, len(buf))
+	n = buf
}

diff {
-		p = main.Strstr(f.Name, "runtime/runtime.go")
-		if p != "" {
-			p[0] = '\x00'
-			gdbscript = fmt.Sprintf("%sruntime/runtime-gdb.py", f.Name)
-			p[0] = 'r'
-			break
-		}
+		_ = p
+		if i := strings.Index(f.Name, "runtime/runtime.go"); i >= 0 {
+			gdbscript = f.Name[:i] + "runtime/runtime-gdb.py"
+			break
+		}
}

func expandpkg(t0 string, pkg string) string {
	return strings.Replace(t0, `"".`, pkg+".", -1)
}

slice Link.library Link.libraryp Link.nlibrary
slice Link.libdir Link.nlibdir Link.maxlibdir
slice LSym.dynexp LSym.ndynexp
slice Pkg.impby Pkg.nimpby Pkg.mimpby
slice dylib ndylib
slice load nload
slice dynexp ndynexp
rename len len_
slice ldflag nldflag
slice LdMachoDysymtab.indir 
slice LdMachoObj.cmd
slice LdMachoSymtab.sym
slice hostobj nhostobj mhostobj
slice MachoLoad.data MachoLoad.ndata
slice renumberfiles.files renumberfiles.nfiles
slice findfunctab.indexes
slice dd
slice ldmain.argv ldmain.argc


func Cwrite(p []byte) {
	Bwrite(&coutbuf, p)
}

bool ispubname.return

diff {
-	Cput(LINE_BASE)   // line_base
+	Cput(LINE_BASE & 0xFF)   // line_base
}

diff {
			// Drop the package prefix from locals and arguments.
-			nn = main.Strrchr(n, '.')
-
-			if nn != "" {
-				n = nn[1:]
-			}
+			_ = nn
+			if i := strings.LastIndex(n, "."); i >= 0 {
+				n = n[i+1:]
+			}
}

bool ispubtype.return

diff {
-func writepub(ispub func(*DWDie) int) int64 {
+func writepub(ispub func(*DWDie) bool) int64 {
}

diff {
-			if ispub(die) == 0 {
+			if !ispub(die) {
}

slice buildinfo buildinfolen
delete emallocz estrdup erealloc
bool parsepkgdata.inquote

diff {
-	sh.entsize = uint64(Thearch.Ptrsize) * (2 + (uint64(bool2int(sh.type_ == SHT_RELA))))
+	sh.entsize = uint64(Thearch.Ptrsize) * 2
+	if sh.type_ == SHT_RELA {
+		sh.entsize += uint64(Thearch.Ptrsize)
+	}
}

diff {
-	sh.entsize = uint64(Thearch.Regsize) * (2 + (uint64(bool2int(typ == SHT_RELA))))
+	sh.entsize = uint64(Thearch.Regsize) * 2
+	if typ == SHT_RELA {
+		sh.entsize += uint64(Thearch.Regsize)
+	}
}

diff {
-	Cwrite(interp, int(sh.size))
+	coutbuf.w.WriteString(interp)
+	Cput(0)
}

diff {
-	n = sizeof(Elf_Note) + sz + resoff%4
+	n = 3*4 + uint64(sz) + resoff%4
}

diff {
const (
	ELF_NOTE_NETBSD_NAMESZ  = 7
	ELF_NOTE_NETBSD_DESCSZ  = 4
	ELF_NOTE_NETBSD_TAG     = 1
	ELF_NOTE_NETBSD_VERSION = 599000000
)

-var ELF_NOTE_NETBSD_NAME string = "NetBSD\x00\x00"
+var ELF_NOTE_NETBSD_NAME = []byte("NetBSD\x00")
}

diff {
const (
	ELF_NOTE_OPENBSD_NAMESZ  = 8
	ELF_NOTE_OPENBSD_DESCSZ  = 4
	ELF_NOTE_OPENBSD_TAG     = 1
	ELF_NOTE_OPENBSD_VERSION = 0
)

-var ELF_NOTE_OPENBSD_NAME string = "OpenBSD\x00"
+var ELF_NOTE_OPENBSD_NAME = []byte("OpenBSD\x00")
}

diff {
const (
	ELF_NOTE_BUILDINFO_NAMESZ = 4
	ELF_NOTE_BUILDINFO_TAG    = 3
)

-var ELF_NOTE_BUILDINFO_NAME string = "GNU\x00"
+var ELF_NOTE_BUILDINFO_NAME = []byte("GNU\x00")
}

diff {
-	Cwrite(ELF_NOTE_NETBSD_NAME, ELF_NOTE_NETBSD_NAMESZ+1)
+	Cwrite(ELF_NOTE_NETBSD_NAME)
+	Cput(0)
}

diff {
-	Cwrite(ELF_NOTE_OPENBSD_NAME, ELF_NOTE_OPENBSD_NAMESZ)
+	Cwrite(ELF_NOTE_OPENBSD_NAME)
}

diff {
-	Cwrite(ELF_NOTE_BUILDINFO_NAME, ELF_NOTE_BUILDINFO_NAMESZ)
+	Cwrite(ELF_NOTE_BUILDINFO_NAME)
}

diff {
-var buildinfolen int
}

diff {
-var buildinfo [32]uint8
+var buildinfo = make([]uint8, 32)
}

diff {
-	Cwrite("\x00\x00\x00", int(Rnd(int64(len(buildinfo)), 4)-int64(len(buildinfo))))
+	var zero = make([]byte, 4)
+	Cwrite(zero[:int(Rnd(int64(len(buildinfo)), 4)-int64(len(buildinfo)))])
}

func Zconv(s string, flag int) string {
	// NOTE: Keep in sync with gc Zconv.
	var n int
	var fp string
	for i := 0; i < len(s); i += n {
		var r rune
		r, n = utf8.DecodeRuneInString(s[i:])
		switch r {
		case utf8.RuneError:
			if n == 1 {
				fp += fmt.Sprintf("\\x%02x", s[i])
				break
			}
			fallthrough

			// fall through
		default:
			if r < ' ' {
				fp += fmt.Sprintf("\\x%02x", r)
				break
			}

			fp += string(r)

		case '\t':
			fp += "\\t"

		case '\n':
			fp += "\\n"

		case '"',
			'\\':
			fp += `\` + string(r)

		case 0xFEFF: // BOM, basically disallowed in source code
			fp += "\\uFEFF"
		}
	}

	return fp
}

diff {
-	if len(i.impby) >= cap(i.impby) {
-		cap(i.impby) *= 2
-		if cap(i.impby) == 0 {
-			cap(i.impby) = 16
-		}
-		i.impby = erealloc(i.impby, cap(i.impby)*sizeof(i.impby[0])).([]*Pkg)
-	}
-
-	i.impby[len(i.impby)] = p
-	len(i.impby)++
+	i.impby = append(i.impby, p)
}

bool LSym.reachable

diff {
-			if len(ldflag)%32 == 0 {
-				ldflag = erealloc(ldflag, (len(ldflag)+32)*sizeof(ldflag[0])).([]string)
-			}
-			ldflag[len(ldflag)] = f[1]
-			len(ldflag)++
+			ldflag = append(ldflag, f[1])
}

diff {
-				if len(dynexp)%32 == 0 {
-					dynexp = erealloc(dynexp, (len(dynexp)+32)*sizeof(dynexp[0])).([]*LSym)
-				}
-				dynexp[len(dynexp)] = s
-				len(dynexp)++
+				dynexp = append(dynexp, s)
}

bool addstrdata.reachable

func ldpkg(f *Biobuf, pkg string, length int64, filename string, whence int) {
	var bdata []byte
	var data string
	var p0, p1 int
	var name string

	if Debug['g'] != 0 {
		return
	}

	if int64(int(length)) != length {
		fmt.Fprintf(os.Stderr, "%s: too much pkg data in %s\n", os.Args[0], filename)
		if Debug['u'] != 0 {
			Errorexit()
		}
		return
	}

	bdata = make([]byte, length)
	if int64(Bread(f, bdata)) != length {
		fmt.Fprintf(os.Stderr, "%s: short pkg read %s\n", os.Args[0], filename)
		if Debug['u'] != 0 {
			Errorexit()
		}
		return
	}
	data = string(bdata)

	// first \n$$ marks beginning of exports - skip rest of line
	p0 = strings.Index(data, "\n$$")
	if p0 < 0 {
		if Debug['u'] != 0 && whence != ArchiveObj {
			fmt.Fprintf(os.Stderr, "%s: cannot find export data in %s\n", os.Args[0], filename)
			Errorexit()
		}
		return
	}

	p0 += 3;
	for p0 < len(data) && data[0] != '\n' {
		p0++
	}

	// second marks end of exports / beginning of local data
	p1 = strings.Index(data[p0:], "\n$$")
	if p1 < 0 {
		fmt.Fprintf(os.Stderr, "%s: cannot find end of exports in %s\n", os.Args[0], filename)
		if Debug['u'] != 0 {
			Errorexit()
		}
		return
	}
	p1 += p0

	for p0 < p1 && (data[p0] == ' ' || data[0] == '\t' || data[0] == '\n') {
		p0++
	}
	if p0 < p1 {
		if !strings.HasPrefix(data[p0:], "package ") {
			fmt.Fprintf(os.Stderr, "%s: bad package section in %s - %.20s\n", os.Args[0], filename, data[p0:])
			if Debug['u'] != 0 {
				Errorexit()
			}
			return
		}

		p0 += 8
		for p0 < p1 && (data[p0] == ' ' || data[p0] == '\t' || data[p0] == '\n') {
			p0++
		}
		name = data[p0:]
		for p0 < p1 && data[p0] != ' ' && data[p0] != '\t' && data[p0] != '\n' {
			p0++
		}
		if Debug['u'] != 0 && whence != ArchiveObj && (p0+6 > p1 || !strings.HasPrefix(data[p0:], " safe\n")) {
			fmt.Fprintf(os.Stderr, "%s: load of unsafe package %s\n", os.Args[0], filename)
			nerrors++
			Errorexit()
		}

		name = name[:p1-p0]
		if p0 < p1 {
			if data[p0] == '\n' {
				p0++
			} else {
				p0++
				for p0 < p1 && data[p0] != '\n' {
					p0++
				}
			}
		}

		if pkg == "main" && name != "main" {
			fmt.Fprintf(os.Stderr, "%s: %s: not package main (package %s)\n", os.Args[0], filename, name)
			nerrors++
			Errorexit()
		}

		loadpkgdata(filename, pkg, data[p0:p1])
	}

	// __.PKGDEF has no cgo section - those are in the C compiler-generated object files.
	if whence == Pkgdef {
		return
	}

	// look for cgo section
	p0 = strings.Index(data[p1:], "\n$$  // cgo")
	if p0 >= 0 {
		p0 += p1
		i := strings.IndexByte(data[p0+1:], '\n')
		if i < 0 {
			fmt.Fprintf(os.Stderr, "%s: found $$ // cgo but no newline in %s\n", os.Args[0], filename)
			if Debug['u'] != 0 {
				Errorexit()
			}
			return
		}
		p0 += 1+i

		p1 = strings.Index(data[p0:], "\n$$")
		if p1 < 0 {
			p1 = strings.Index(data[p0:], "\n!\n")
		}
		if p1 < 0 {
			fmt.Fprintf(os.Stderr, "%s: cannot find end of // cgo section in %s\n", os.Args[0], filename)
			if Debug['u'] != 0 {
				Errorexit()
			}
			return
		}
		p1 += p0

		loadcgo(filename, pkg, data[p0:p1])
	}
}

slice loadpkgdata.data loadpkgdata.length
slice loadcgo.p loadcgo.n

func parsepkgdata(file string, pkg string, pp *string, prefixp *string, namep *string, defp *string) int {
	var p string
	var prefix string
	var name string
	var def string
	var edef string
	var meth string
	var n int
	var inquote bool

	// skip white space
	p = *pp

loop:
	for len(p) > 0 && (p[0] == ' ' || p[0] == '\t' || p[0] == '\n') {
		p = p[1:]
	}
	if len(p) == 0 || strings.HasPrefix(p, "$$\n") {
		return 0
	}

	// prefix: (var|type|func|const)
	prefix = p

	if len(p) < 7 {
		return -1
	}
	if strings.HasPrefix(p, "var ") {
		p = p[4:]
	} else if strings.HasPrefix(p, "type ") {
		p = p[5:]
	} else if strings.HasPrefix(p, "func ") {
		p = p[5:]
	} else if strings.HasPrefix(p, "const ") {
		p = p[6:]
	} else if strings.HasPrefix(p, "import ") {
		p = p[7:]
		for len(p) > 0 && p[0] != ' ' {
			p = p[1:]
		}
		p = p[1:]
		name := p
		for len(p) > 0 && p[0] != '\n' {
			p = p[1:]
		}
		if len(p) == 0 {
			fmt.Fprintf(os.Stderr, "%s: %s: confused in import line\n", os.Args[0], file)
			nerrors++
			return -1
		}
		name = name[:len(name)-len(p)]
		p = p[1:]
		imported(pkg, name)
		goto loop
	} else {
		fmt.Fprintf(os.Stderr, "%s: %s: confused in pkg data near <<%.40s>>\n", os.Args[0], file, prefix)
		nerrors++
		return -1
	}
	
	prefix = prefix[:len(prefix)-len(p)-1]

	// name: a.b followed by space
	name = p

	inquote = false
	for len(p) > 0 {
		if p[0] == ' ' && !inquote {
			break
		}

		if p[0] == '\\' {
			p = p[1:]
		} else if p[0] == '"' {
			inquote = !inquote
		}

		p = p[1:]
	}

	if len(p) == 0 {
		return -1
	}
	name = name[:len(name)-len(p)]
	p = p[1:]

	// def: free form to new line
	def = p

	for len(p) > 0 && p[0] != '\n' {
		p = p[1:]
	}
	if len(p) == 0 {
		return -1
	}
	def = def[:len(def)-len(p)]
	var defbuf *bytes.Buffer
	p = p[1:]

	// include methods on successive lines in def of named type
	for parsemethod(&p, &meth) > 0 {
		if defbuf == nil {
			defbuf = new(bytes.Buffer)
			defbuf.WriteString(def)
		}
		defbuf.WriteString("\n\t")
		defbuf.WriteString(meth)
	}
	if defbuf != nil {
		def = defbuf.String()
	}

	name = expandpkg(name, pkg)
	def = expandpkg(def, pkg)

	// done
	*pp = p

	*prefixp = prefix
	*namep = name
	*defp = def
	return 1
}

func parsemethod(pp *string, methp *string) int {
	var p string

	// skip white space
	p = *pp

	for len(p) > 0 && (p[0] == ' ' || p[0] == '\t') {
		p = p[1:]
	}
	if len(p) == 0 {
		return 0
	}

	// might be a comment about the method
	if strings.HasPrefix(p, "//") {
		goto useline
	}

	// if it says "func (", it's a method
	if strings.HasPrefix(p, "func (") {
		goto useline
	}
	return 0

	// definition to end of line
useline:
	*methp = p

	for len(p) > 0 && p[0] != '\n' {
		p = p[1:]
	}
	if len(p) == 0 {
		fmt.Fprintf(os.Stderr, "%s: lost end of line in method definition\n", os.Args[0])
		*pp = ""
		return -1
	}

	*methp = (*methp)[:len(*methp)-len(p)]
	*pp = p[1:]
	return 1
}
diff {
func loadpkgdata(file string, pkg string, data string) {
	var p string
-	var ep string
	var prefix string
	var name string
	var def string
	var x *Import

	file = file
	p = data
-	ep = data[len(data):]
-	for parsepkgdata(file, pkg, &p, ep, &prefix, &name, &def) > 0 {
+	for parsepkgdata(file, pkg, &p, &prefix, &name, &def) > 0 {
}

diff {
func loadcgo(file string, pkg string, p string) {
-	var pend string
}

diff {
-	pend = p[len(p):]
	p0 = ""
-	for ; p < pend; p = next {
-		next = main.Strchr(p, '\n')
-		if next == "" {
-			next = ""
-		} else {
-			next[0] = '\x00'
-			next = next[1:]
-		}
+	for ; p != ""; p = next {
+		if i := strings.Index(p, "\n"); i >= 0 {
+			p, next = p[:i], p[i+1:]
+		} else {
+			next = ""
+		}
}

diff {
-			q = main.Strchr(remote, '#')
-			if q != "" {
-				q[0] = '\x00'
-				q = q[1:]
-			}
+			q = ""
+			if i := strings.Index(remote, "#"); i >= 0{
+				remote, q = remote[:i], remote[i+1:]
+			}
}

slice loadcgo.f loadcgo.nf

diff {
-	var f [10]string
+	var f []string
}

diff {
-		f = f[:main.Tokenize(p, (*string)(f))]
+		f = tokenize(p)
}

func addlib(ctxt *Link, src string, obj string, pathname string) {
	name := path.Clean(pathname)

	// runtime.a -> runtime
	pkg := name
	if len(pkg) >= 2 && pkg[len(pkg)-2] == '.' {
		pkg = pkg[:len(pkg)-2]
	}

	// already loaded?
	for i := 0; i < len(ctxt.Library); i++ {
		if ctxt.Library[i].Pkg == pkg {
			return
		}
	}
	
	var pname string
	if (ctxt.Windows == 0 && strings.HasPrefix(name, "/")) || (ctxt.Windows != 0 && len(name) >= 2 && name[1] == ':') {
		pname = name
	} else {
		// try dot, -L "libdir", and then goroot.
		for _, dir := range ctxt.Libdir {
			pname = dir + "/" + name
			if _, err := os.Stat(pname); err == nil {
				break
			}
		}
	}

	pname = path.Clean(pname)

	if ctxt.Debugvlog > 1 && ctxt.Bso != nil {
		fmt.Fprintf(ctxt.Bso, "%5.2f addlib: %s %s pulls in %s\n", elapsed(), obj, src, pname)
	}

	addlibpath(ctxt, src, obj, pname, pkg)
}

diff {
-	if len(ctxt.Library) == cap(ctxt.Library) {
-		cap(ctxt.Library) = 50 + 2*len(ctxt.Library)
-		ctxt.Library = erealloc(ctxt.Library, sizeof(ctxt.Library[0])*cap(ctxt.Library)).([]Library)
-	}
-
-	l = &ctxt.Library[len(ctxt.Library)]
-	len(ctxt.Library)++
+	ctxt.Library = append(ctxt.Library, Library{})
+	l = &ctxt.Library[len(ctxt.Library)-1]
	l.Objref = objref
	l.Srcref = srcref
	l.File = file
	l.Pkg = pkg
}

delete find1 nuxiinit

diff {
func ldelf(f *Biobuf, pkg string, length int64, pn string) {
+	var err error
}

diff {
-	if Bread(f, hdrbuf, len(hdrbuf)) != len(hdrbuf) {
-		goto bad
-	}
-	hdr = (*ElfHdrBytes)(hdrbuf)
-	if main.Memcmp(hdr.Ident, ElfMagic, 4) != 0 {
-		goto bad
-	}
+	if Bread(f, hdrbuf[:]) != len(hdrbuf) {
+		goto bad
+	}
+	hdr = new(ElfHdrBytes)
+	binary.Read(bytes.NewReader(hdrbuf[:]), binary.BigEndian, hdr) // only byte arrays; byte order doesn't matter
+	if string(hdr.Ident[:4]) != "\x7FELF" {
+		goto bad
+	}
}

diff {
-		hdr = (*ElfHdrBytes64)(hdrbuf)
+		hdr = new(ElfHdrBytes64)
+		binary.Read(bytes.NewReader(hdrbuf[:]), binary.BigEndian, hdr) // only byte arrays; byte order doesn't matter
}

diff {
-			main.Werrstr("short read")
-			if Bread(f, &b, sizeof(b)) != sizeof(b) {
+			if err = binary.Read(f, e, &b); err != nil {
}

diff {
-		var b *ElfSymBytes64
-
-		b = (*ElfSymBytes64)(elfobj.symtab.base[i*sizeof(*b):])
-		sym.name = string(elfobj.symstr.base)[elfobj.e.e32(b.Name[:]):]
+		b := new(ElfSymBytes64)
+		binary.Read(bytes.NewReader(elfobj.symtab.base[i*ELF64SYMSIZE:(i+1)*ELF64SYMSIZE]), elfobj.e, b)
+		sym.name = cstring(elfobj.symstr.base[elfobj.e.e32(b.Name[:]):])
}

diff {
-		var b *ElfSymBytes
-
-		b = (*ElfSymBytes)(elfobj.symtab.base[i*sizeof(*b):])
-		sym.name = string(elfobj.symstr.base)[elfobj.e.e32(b.Name[:]):]
+		b := new(ElfSymBytes)
+		binary.Read(bytes.NewReader(elfobj.symtab.base[i*ELF32SYMSIZE:(i+1)*ELF32SYMSIZE]), elfobj.e, b)
+		sym.name = cstring(elfobj.symstr.base[elfobj.e.e32(b.Name[:]):])
}

export ElfSymBytes ElfSymBytes64 ElfHdrBytes ElfHdrBytes64 ElfSectBytes ElfSectBytes64

diff {
- elfobj.nsymtab = elfobj.symtab.size / sizeof(ElfSymBytes64)
+ elfobj.nsymtab = int(elfobj.symtab.size / ELF64SYMSIZE)
}

diff {
- elfobj.nsymtab = elfobj.symtab.size / sizeof(ElfSymBytes)
+ elfobj.nsymtab = int(elfobj.symtab.size / ELF32SYMSIZE)
}

diff {
-	if Bseek(elfobj.f, int64(uint64(elfobj.base)+sect.off), 0) < 0 || uint64(Bread(elfobj.f, sect.base, int(sect.size))) != sect.size {
+	if Bseek(elfobj.f, int64(uint64(elfobj.base)+sect.off), 0) < 0 || Bread(elfobj.f, sect.base) != len(sect.base) {
-		return -1
+		return err
	}

-	return 0
+	return nil
}

diff {
-func elfmap(elfobj *ElfObj, sect *ElfSect) int {
+func elfmap(elfobj *ElfObj, sect *ElfSect) (err error) {
	if sect.base != nil {
-		return 0
+		return nil
}

diff {
-func readelfsym(elfobj *ElfObj, i int, sym *ElfSym, needSym int) int {
+func readelfsym(elfobj *ElfObj, i int, sym *ElfSym, needSym int) (err error) {
}
diff {
	sym.sym = s

-	return 0
+	return nil
}

ptr reltype.siz

diff {
-	if elfmap(elfobj, sect) < 0 {
+	if err = elfmap(elfobj, sect); err != nil {
}
diff {
-	if elfmap(elfobj, elfobj.symtab) < 0 {
+	if err = elfmap(elfobj, elfobj.symtab); err != nil {
}
diff {
-	if elfmap(elfobj, elfobj.symstr) < 0 {
+	if err = elfmap(elfobj, elfobj.symstr); err != nil {
}
diff {
-		if sect.type_ != ElfSectNobits && elfmap(elfobj, sect) < 0 {
+		if sect.type_ != ElfSectNobits {
+			if err = elfmap(elfobj, sect); err != nil {
			goto bad
+			}
		}
}

diff {
-		if readelfsym(elfobj, i, &sym, 1) < 0 {
+		if err = readelfsym(elfobj, i, &sym, 1); err != nil {
}
diff {
-		if elfmap(elfobj, rsect) < 0 {
+		if err = elfmap(elfobj, rsect); err != nil {
}

diff {
-				if readelfsym(elfobj, int(info>>32), &sym, 0) < 0 {
+				if err = readelfsym(elfobj, int(info>>32), &sym, 0); err != nil {
}

diff {
-		rela = bool2int(rsect.type_ == ElfSectRela)
+		rela = 0
+		if rsect.type_ == ElfSectRela {
+			rela = 1
+		}
}

diff {
-		main.Strecpy(c.seg.name, c.seg.name[sizeof(c.seg.name):], string(p)[8:])
+		c.seg.name = cstring(p[8:24])
}

diff {
-			main.Strecpy(s.name, s.name[sizeof(s.name):], string(p)[0:])
-			main.Strecpy(s.segname, s.segname[sizeof(s.segname):], string(p)[16:])
+			s.name = cstring(p[0:16])
+			s.segname = cstring(p[16:32])
}

diff {
-	if Bseek(m.f, m.base+int64(sect.reloff), 0) < 0 || Bread(m.f, buf, n) != n {
+	if Bseek(m.f, m.base+int64(sect.reloff), 0) < 0 || Bread(m.f, buf) != n {
}

diff {
-	p = make([]byte, 4)
+	p = make([]byte, n*4)
-	if Bseek(m.f, m.base+int64(d.indirectsymoff), 0) < 0 || Bread(m.f, p, n*4) != n*4 {
+	if Bseek(m.f, m.base+int64(d.indirectsymoff), 0) < 0 || Bread(m.f, p) != len(p) {
}
diff {
-	d.indir = []uint32((*uint32)(p))
+	d.indir = make([]uint32, n)
}

diff {
-	if Bseek(m.f, m.base+int64(symtab.stroff), 0) < 0 || uint32(Bread(m.f, strbuf, int(symtab.strsize))) != symtab.strsize {
+	if Bseek(m.f, m.base+int64(symtab.stroff), 0) < 0 || Bread(m.f, strbuf) != len(strbuf) {
}

diff {
-	if Bseek(m.f, m.base+int64(symtab.symoff), 0) < 0 || Bread(m.f, symbuf, n) != n {
+	if Bseek(m.f, m.base+int64(symtab.symoff), 0) < 0 || Bread(m.f, symbuf) != len(symbuf) {
}

diff {
-	if Bread(f, hdr, len(hdr)) != len(hdr) {
+	if Bread(f, hdr[:]) != len(hdr) {
}

diff {
-		Bread(f, tmp, 4) // skip reserved word in header
+		Bread(f, tmp[:4]) // skip reserved word in header
}

diff {
-	if Bseek(f, m.base+int64(c.seg.fileoff), 0) < 0 || uint32(Bread(f, dat, int(c.seg.filesz))) != c.seg.filesz {
+	if Bseek(f, m.base+int64(c.seg.fileoff), 0) < 0 || Bread(f, dat) != len(dat) {
}

diff {
func ldmacho(f *Biobuf, pkg string, length int64, pn string) {
+	var err error
}

diff {
-	m = (*LdMachoObj)(make([]byte, sizeof(*m)+ncmd*sizeof(LdMachoCmd)+cmdsz))
+	m = new(LdMachoObj)
}
diff {
-	m.cmd = []LdMachoCmd((*LdMachoCmd)(m + 1))
+	m.cmd = make([]LdMachoCmd, ncmd)
}
diff {
-	cmdp = []byte(m.cmd[ncmd:])
+	cmdp = make([]byte, cmdsz)
}

slice LdMachoSect.rel

diff {
-		main.Qsort(r, rpi, sizeof(r[0]), rbyoff)
+		sort.Sort(rbyoff(r[:rpi]))
}

diff {
-	strbuf = string(make([]byte, symtab.strsize))
+	strbuf = make([]byte, symtab.strsize)
}

slice macholoadsym.strbuf

diff {
-	if uint32(Bread(f, cmdp, int(cmdsz))) != cmdsz {
+	if Bread(f, cmdp) != len(cmdp) {
}

diff {
func macholoadsym(m *LdMachoObj, symtab *LdMachoSymtab) int {
-	var strbuf string
+	var strbuf []byte
}

bool ldmacho.is64

diff {
func ldpe(f *Biobuf, pkg string, length int64, pn string) {
+	var err error
}

diff {
-	if Bread(f, &peobj.fh, sizeof(peobj.fh)) != sizeof(peobj.fh) {
+	if err = binary.Read(f, binary.LittleEndian, &peobj.fh); err != nil {
}

diff {
-		if Bread(f, &peobj.sect[i].sh, sizeof(sh)) != sizeof(sh) {
+		if err = binary.Read(f, binary.LittleEndian, &peobj.sect[i].sh); err != nil {
}

diff {
-		s.name = strbuf[v:]
+		s.name = cstring(strbuf[v:])
}

diff {
type LdMachoSymtab struct {
	symoff  uint32
	nsym    uint32
	stroff  uint32
	strsize uint32
-	str     string
+	str []byte
}


diff {
-		peobj.sect[i].name = string(peobj.sect[i].sh.Name)
+		peobj.sect[i].name = cstring(peobj.sect[i].sh.Name[:])
}

diff {
-	if Bread(f, symbuf, 4) != 4 {
+	if Bread(f, symbuf[:4]) != 4 {
}

diff {
-	peobj.snames = string(make([]byte, l))
+	peobj.snames = make([]byte, l)
}

diff {
-	if uint32(Bread(f, peobj.snames, int(l))) != l {
+	if Bread(f, peobj.snames) != len(peobj.snames) {
}

diff {
	fh     IMAGE_FILE_HEADER
-	snames string
+	snames []byte
}

diff {
-		peobj.sect[i].name = string(&peobj.snames[l])
+		peobj.sect[i].name = cstring(peobj.snames[l:])
}

diff {
-			peobj.pesym[i].name = string(&peobj.snames[l]) // sym name length <= 8
+			peobj.pesym[i].name = cstring(peobj.snames[l:]) // sym name length <= 8
}

diff {
-			peobj.pesym[i].name = string(make([]byte, 9))
-			main.Strncpy(peobj.pesym[i].name, string(symbuf), 8)
-			peobj.pesym[i].name[8] = 0
+			peobj.pesym[i].name = cstring(symbuf[:8])
}

diff {
-		if Bread(f, symbuf, len(symbuf)) != len(symbuf) {
+		if Bread(f, symbuf[:]) != len(symbuf) {
}

diff {
-		main.Qsort(r, rsect.sh.NumberOfRelocations, sizeof(r[0]), rbyoff)
+		sort.Sort(rbyoff(r[:rsect.sh.NumberOfRelocations]))
}

diff {
-			l = Le32([]byte(&symbuf[4]))
+			l = Le32(symbuf[4:])
}

diff {
-		peobj.pesym[i].value = Le32([]byte(&symbuf[8]))
+		peobj.pesym[i].value = Le32(symbuf[8:])
-		peobj.pesym[i].sectnum = Le16([]byte(&symbuf[12]))
+		peobj.pesym[i].sectnum = Le16(symbuf[12:])
		peobj.pesym[i].sclass = symbuf[16]
		peobj.pesym[i].aux = symbuf[17]
-		peobj.pesym[i].type_ = Le16([]byte(&symbuf[14]))
+		peobj.pesym[i].type_ = Le16(symbuf[14:])
}

diff {
-			rva = Le32([]byte(&symbuf[0]))
-			symindex = Le32([]byte(&symbuf[4]))
-			type_ = Le16([]byte(&symbuf[8]))
+			rva = Le32(symbuf[0:])
+			symindex = Le32(symbuf[4:])
+			type_ = Le16(symbuf[8:])
}

diff {
-	if Bseek(peobj.f, int64(peobj.base)+int64(sect.sh.PointerToRawData), 0) < 0 || uint32(Bread(peobj.f, sect.base, int(sect.sh.SizeOfRawData))) != sect.sh.SizeOfRawData {
+	if Bseek(peobj.f, int64(peobj.base)+int64(sect.sh.PointerToRawData), 0) < 0 || Bread(peobj.f, sect.base) != len(sect.base) {
}

bool issect.return

diff {
-			name = string(&name[6]) // __imp_Name => Name
+			name = name[6:] // __imp_Name => Name
}

diff {
-			name = string(&name[1]) // _Name => Name
+			name = name[1:] // _Name => Name
}

diff {
-	p = main.Strchr(name, '@')
-
-	if p != "" {
-		p = ""
-	}
+	if i := strings.LastIndex(name, "@"); i >= 0 {
+		name = name[:i]
+	}
}

diff {
-func readpesym(peobj *PeObj, i int, y **PeSym) int {
+func readpesym(peobj *PeObj, i int, y **PeSym) (err error) {
}

bool LdMachoObj.is64

diff {
-			if readpesym(peobj, int(symindex), &sym) < 0 {
+			if err = readpesym(peobj, int(symindex), &sym); err != nil {
}

diff {
-		if readpesym(peobj, i, &sym) < 0 {
+		if err = readpesym(peobj, i, &sym); err != nil {
}

diff {
-			if Bread(f, symbuf, 10) != 10 {
+			if Bread(f, symbuf[:10]) != 10 {
}

func Lflag(arg string) {
	Ctxt.Libdir = append(Ctxt.Libdir, arg)
}

func mayberemoveoutfile() {
	if fi, err := os.Lstat(outfile); err == nil && !fi.Mode().IsRegular() {
		return
	}
	os.Remove(outfile)
}

diff {
-	cout = main.Create(outfile, 1, 0775)
-	if cout < 0 {
+	f, err := os.OpenFile(outfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)
+	if err != nil {
		Diag("cannot create %s: %v", outfile, err)
		Errorexit()
	}

+	cout = f
+	coutbuf = *Binitw(f)
-	Binit(&coutbuf, cout, main.OWRITE)
}

diff {
-		INITENTRY = string(make([]byte, main.Strlen(goarch)+main.Strlen(goos)+20))
}

diff {
-	if cout >= 0 {
-		// For rmtemp run at atexit time on Windows.
-		main.Close(cout)
-	}
+	if cout != nil {
+		// For rmtemp run at atexit time on Windows.
+		cout.Close()
+	}
}

diff {
-var cout int = -1
+var cout *os.File
}

diff {
-	main.Exits("")
+	Exit(0)
}

bool iscgo

diff {
-	if len(hostobj) >= cap(hostobj) {
-		if cap(hostobj) == 0 {
-			cap(hostobj) = 16
-		} else {
-			cap(hostobj) *= 2
-		}
-		hostobj = erealloc(hostobj, cap(hostobj)*sizeof(hostobj[0])).([]Hostobj)
-	}
-
-	h = &hostobj[len(hostobj)]
-	len(hostobj)++
+	hostobj = append(hostobj, Hostobj{})
+	h = &hostobj[len(hostobj)-1]
}

diff {
-		f = Bopen(h.file, main.OREAD)
+		var err error
+		f, err = Bopenr(h.file)
}

diff {
-	removeall(tmpdir)
+	os.RemoveAll(tmpdir)
}

diff {
-		main.Atexit(rmtemp)
+		AtExit(rmtemp)
}

diff {
	// change our output to temporary object file
-	main.Close(cout)
+	cout.Close()

	p = fmt.Sprintf("%s/go.o", tmpdir)
-	cout = main.Create(p, 1, 0775)
-	if cout < 0 {
+	var err error
+	cout, err = os.OpenFile(p, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)
+	if err != nil {
}

diff {
-	fmtinstall('i', iconv)
-	fmtinstall('Y', Yconv)
-	fmtinstall('Z', Zconv)
}

diff {
-		if cout >= 0 {
+		if cout != nil {
			mayberemoveoutfile()
		}
}

diff {
-		iscgo |= Ctxt.Library[i].Pkg == "runtime/cgo"
+		iscgo = iscgo || Ctxt.Library[i].Pkg == "runtime/cgo"
}

func nextar(bp *Biobuf, off int64, a *ArHdr) int64 {
	if off&1 != 0 {
		off++
	}
	Bseek(bp, off, 0)
	buf := make([]byte, SAR_HDR)
	if n := Bread(bp, buf); n < len(buf) {
		if n >= 0 {
			return 0
		}
		return -1
	}
	
	a.name = artrim(buf[0:16])
	a.date = artrim(buf[16:28])
	a.uid = artrim(buf[28:34])
	a.gid = artrim(buf[34:40])
	a.mode = artrim(buf[40:48])
	a.size = artrim(buf[48:58])
	a.fmag = artrim(buf[58:60])
	
	arsize := atolwhex(a.size)
	if arsize&1 != 0 {
		arsize++
	}
	return int64(arsize) + SAR_HDR
}

func atolwhex(s string) int64 {
	n, _ := strconv.ParseInt(s, 0, 64)
	return n
}

diff {
-	var magbuf string
}

diff {
-	l = int64(Bread(f, magbuf, SARMAG))
-	if l != SARMAG || !strings.HasPrefix(magbuf, ARMAG) {
+	magbuf := make([]byte, len(ARMAG))
+	if Bread(f, magbuf) != len(magbuf) || !strings.HasPrefix(string(magbuf), ARMAG) {
}

diff {
-		l = SARNAME
-		for l > 0 && arhdr.name[l-1] == ' ' {
-			l--
-		}
-		pname = fmt.Sprintf("%s(%.*s)", file, main.Utfnlen(arhdr.name, int(l)), arhdr.name)
+		pname = fmt.Sprintf("%s(%s)", file, arhdr.name)
}

delete dowrite

diff {
-	argv = make([]string, (14 + len(hostobj) + len(ldflag) + c))
-	argc = 0
}

diff {
	var argv []string
	var c int
	var i int
-	var w int
	var n int
-	var argc int
}

diff {
-	f = Bopen(file, 0)
-	if f == nil {
-		Diag("cannot open file: %s", file)
+	var err error
+	f, err = Bopenr(file)
+	if err != nil {
+		Diag("cannot open file %s: %v", file, err)
		Errorexit()
	}
}

diff {
-		tmpdir = mktempdir()
+		dir, err := ioutil.TempDir("", "go-link-")
+		if err != nil {
+			log.Fatal(err)
+		}
+		tmpdir = dir
}

diff {
-	Binit(&coutbuf, cout, main.OWRITE)
+	coutbuf = *Binitw(cout)
}

diff {
-	c = 0
-	p = extldflags
-	for p != "" {
-		for p[0] == ' ' {
-			p = p[1:]
-		}
-		if p[0] == '\x00' {
-			break
-		}
-		c++
-		p = main.Strchr(p[1:], ' ')
-	}
-
}

diff {
-		w = main.Create(p, 1, 0775)
-		if w < 0 {
+		w, err := os.Create(p)
+		if err != nil {
}

diff {
-			dowrite(w, hostlink_buf, n)
+			if _, err = w.Write(hostlink_buf[:n]); err != nil {
+				log.Fatal(err)
+			}
}

diff {
-		if main.Close(w) < 0 {
+		if err = w.Close(); err != nil {
}

diff {
-	p = extldflags
-	for p != "" {
-		for p[0] == ' ' {
-			p[0] = '\x00'
-			p = p[1:]
-		}
-		if p[0] == '\x00' {
-			break
-		}
+	for _, p = range strings.Fields(extldflags) {
}

diff {
-		if Iself && strings.HasPrefix(p, "-static") && (p[7] == ' ' || p[7] == '\x00') {
+		if Iself && p == "-static" {
-			for i = 0; i < argc; i++ {
+			for i = range argv {
}

bool iself

diff {
-
-		p = main.Strchr(p[1:], ' ')
	}
-
-	argv[argc] = ""
}

diff {
-		for i = 0; i < argc; i++ {
+		for i = range argv {
			fmt.Fprintf(&Bso, " %v", plan9quote(argv[i]))
		}
}

diff {
-	if runcmd(&argv[0]) < 0 {
+	if out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {
		Ctxt.Cursym = nil
-		Diag("%s: running %s failed: %v", main.Argv0, argv[0], err)
+		Diag("%s: running %s failed: %v\n%s", os.Args[0], argv[0], err, out)
}

diff {
-	line = Brdline(f, '\n').(string)
+	line = Brdline(f, '\n')
}
diff {
	n = Blinelen(f) - 1
-	line[n] = '\x00'
}

diff {
-	line[n] = ' '
-	if !strings.HasPrefix(line+10, t) && Debug['f'] == 0 {
-		line[n] = '\x00'
+	line = strings.TrimRight(line, "\n")
+	if !strings.HasPrefix(line[10:] + " ", t) && Debug['f'] == 0 {
		Diag("%s: object is [%s] expected [%s]", pn, line[10:], t)
-
}

diff {
-	line[n] = '\x00'
-
-	if n-10 > len(t) {
+	if len(line) >= len(t)+10 {
		if theline == "" {
			theline = line[10:]
-		} else if theline != line+10 {
+		} else if theline != line[10:] {
-			line[n] = '\x00'
			Diag("%s: object is [%s] expected [%s]", pn, line[10:], theline)
-
			return
		}
	}
-
-	line[n] = '\n'
}

diff {
-var hostlink_buf string
+var hostlink_buf = make([]byte, 64*1024)
}

diff {
-	quotefmtinstall()
}

diff {
-	main.Werrstr("short read")
	if Bseek(peobj.f, int64(peobj.base)+int64(sect.sh.PointerToRawData), 0) < 0 || Bread(peobj.f, sect.base) != len(sect.base) {
		return -1
}

diff {
-			n = Bread(f, hostlink_buf, sizeof(hostlink_buf))
+			n = Bread(f, hostlink_buf)
}

diff {
-	n = Blinelen(f) - 1
	if !strings.HasPrefix(line, "go object ") {
-		if len(pn) > 3 && pn+(main.Strlen(pn)-3) == ".go" {
+		if strings.HasSuffix(pn, ".go") {
}

delete mal
delete unmal

func pathtoprefix(s string) string {
	slash := strings.LastIndex(s, "/")
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			goto escape
		}
	}
	return s

escape:
	var buf bytes.Buffer
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			fmt.Fprintf(&buf, "%%%02x", c)
			continue
		}
		buf.WriteByte(c)
	}
	return buf.String()
}

bool haslinkregister.return

diff {
-	Bputc(&coutbuf, int(c))
+	Bputc(&coutbuf, c)
}

func Diag(format string, args ...interface{}) {
	tn := ""
	sep := ""
	if Ctxt.Cursym != nil {
		tn = Ctxt.Cursym.Name
		sep = ": "
	}
	fmt.Printf("%s%s%s\n", tn, sep, fmt.Sprintf(format, args...))

	nerrors++
	if nerrors > 20 {
		fmt.Printf("too many errors\n")
		Errorexit()
	}
}

func newMachoLoad(type_ uint32, ndata uint32) *MachoLoad {
	if macho64 && (ndata&1 != 0) {
		ndata++
	}
	
	load = append(load, MachoLoad{})
	l := &load[len(load)-1]
	l.type_ = type_
	l.data = make([]uint32, ndata)
	return l
}

bool macho64

diff {
-	if len(dylib)%32 == 0 {
-		dylib = erealloc(dylib, (len(dylib)+32)*sizeof(dylib[0])).([]string)
-	}
-	dylib[len(dylib)] = lib
-	len(dylib)++
+	dylib = append(dylib, lib)
}

diff {
-	buf = fmt.Sprintf("__%s", sect.Name[1:])
-	for p = buf; p[0] != 0; p = p[1:] {
-		if p[0] == '.' {
-			p[0] = '_'
-		}
-	}
+	buf = "__" + strings.Replace(sect.Name[1:], ".", "_", -1)
}

diff {
-			string(&ml.data[1]) = "/usr/lib/dyld"
+			stringtouint32(ml.data[1:], "/usr/lib/dyld")
}

diff {
-				string(&ml.data[4]) = dylib[i]
+				stringtouint32(ml.data[4:], dylib[i])
}

diff {
-		Cwrite(s1.P, int(s1.Size))
-		Cwrite(s2.P, int(s2.Size))
-		Cwrite(s3.P, int(s3.Size))
-		Cwrite(s4.P, int(s4.Size))
+		Cwrite(s1.P[:s1.Size])
+		Cwrite(s2.P[:s2.Size])
+		Cwrite(s3.P[:s3.Size])
+		Cwrite(s4.P[:s4.Size])
}

diff {
	var buf [8]uint8
	var start int64
	var lib string

	start = Boffset(f)
	ctxt.Version++
	buf = [8]uint8{}
-	Bread(f, buf, len(buf))
-	if main.Memcmp(buf, startmagic, sizeof(buf)) != 0 {
+	Bread(f, buf[:])
+	if string(buf[:]) != startmagic {
}

diff {
	buf = [8]uint8{}
-	Bread(f, buf, len(buf))
-	if main.Memcmp(buf, endmagic, sizeof(buf)) != 0 {
+	Bread(f, buf[:])
+	if string(buf[:]) != endmagic {
}

diff {
-	cap(s.P) = len(s.P)
}
diff {
-		cap(s.R) = nreloc
}
diff {
-		if len(s.P) != len(dup.P) || main.Memcmp(s.P, dup.P, len(s.P)) != 0 {
+		if !bytes.Equal(s.P, dup.P) {
}

func rddata(f *Biobuf, pp *[]byte) {
	n := rdint(f)
	*pp = make([]byte, n)
	Bread(f, *pp)
}

func rdstring(f *Biobuf) string {
	n := rdint(f)
	p := make([]byte, n)
	Bread(f, p)
	return string(p)
}
diff {
-	p = string(make([]byte, n+1))
-	Bread(f, p, n)
+	buf := make([]byte, n)
+	Bread(f, buf)
+	p = string(buf)
}
diff {
-			i32 = int32(main.Strtoul(s.Name[5:], nil, 16))
+			x, _ := strconv.ParseUint(s.Name[5:], 16, 32)
+			i32 = int32(x)
}
diff {
-			i64 = int64(main.Strtoull(s.Name[5:], nil, 16))
+			x, _ := strconv.ParseUint(s.Name[5:], 16, 64)
+			i64 = int64(x)
}

slice Pcdata.p Pcdata.n Pcdata.m

diff {
-		rddata(f, &pc.Pcsp.P, &len(pc.Pcsp.P))
-		rddata(f, &pc.Pcfile.P, &len(pc.Pcfile.P))
-		rddata(f, &pc.Pcline.P, &len(pc.Pcline.P))
+		rddata(f, &pc.Pcsp.P)
+		rddata(f, &pc.Pcfile.P)
+		rddata(f, &pc.Pcline.P)
}

diff {
-			rddata(f, &pc.Pcdata[i].P, &len(pc.Pcdata[i].P))
+			rddata(f, &pc.Pcdata[i].P)
}

diff {
-	if int32(len(d.P))+n > cap(d.P) {
-		cap(d.P) = (int32(len(d.P)) + n) * 2
-		d.P = erealloc(d.P, cap(d.P)).([]byte)
-	}
+	old := len(d.P)
+	for cap(d.P) < len(d.P) + int(n) {
+		d.P = append(d.P[:cap(d.P)], 0)
+	}
+	d.P = d.P[:old+int(n)]

-	p = d.P[len(d.P):]
+	p = d.P[old:]
	for v = val; v >= 0x80; v >>= 7 {
		p[0] = byte(v | 0x80)
		p = p[1:]
	}
	p[0] = byte(v)
-	len(d.P) += int(n)
}

diff {
-	main.Memmove(ftab.P[start:], d.P, len(d.P))
+	copy(ftab.P[start:], d.P)
}

diff {
-			renumberfiles(Ctxt, pcln.File, (*Pcdata)(pcln.Nfile), &pcln.Pcfile)
+			renumberfiles(Ctxt, pcln.File, &pcln.Pcfile)
}

diff {
-	indexes = []int32((*int32)(make([]byte, 4)))
+	indexes = make([]int32, n)
-	if indexes == nil {
-		Diag("out of memory")
-		Errorexit()
-	}
-
}

diff {
-	string(ftab.P)[start:] = s
+	copy(ftab.P[start:], s)
}

diff {
-	main.Strncpy(string(h.Name), name, len((h.Name)))
+	copy(h.Name[:], name)
}

diff {
-		Diag("%s.PointerToRawData = %#x, want %#x", string(h.Name), uint64(int64(h.PointerToRawData)), uint64(off))
+		Diag("%s.PointerToRawData = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.PointerToRawData)), uint64(off))
}

diff {
-		Diag("%s.VirtualAddress = %#x, want %#x", string(h.Name), uint64(int64(h.VirtualAddress)), uint64(int64(s.Vaddr-PEBASE)))
+		Diag("%s.VirtualAddress = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.VirtualAddress)), uint64(int64(s.Vaddr-PEBASE)))
}

diff {
-		Diag("%s.PointerToRawData = %#x, want %#x", string(h.Name), uint64(int64(h.PointerToRawData)), uint64(int64(s.Fileoff)))
+		Diag("%s.PointerToRawData = %#x, want %#x", cstring(h.Name[:]), uint64(int64(h.PointerToRawData)), uint64(int64(s.Fileoff)))
}

diff {
-		l = sizeof(oh64)
+		l = binary.Size(&oh64)
}

diff {
-		l = sizeof(oh)
+		l = binary.Size(&oh)
}

diff {
func Peinit() {
-	var l int32
+	var l int
}

diff {
-	PEFILEHEADR = int32(Rnd(len(dosstub)+sizeof(fh)+l+sizeof(sh), PEFILEALIGN))
+	PEFILEHEADR = int32(Rnd(int64(len(dosstub)+binary.Size(&fh)+l+binary.Size(&sh)), PEFILEALIGN))
}

diff {
-	Cwrite(dosstub, len(dosstub))
+	Cwrite(dosstub)
}

diff {
-	// TODO: This code should not assume that the
-	// memory representation is little-endian or
-	// that the structs are packed identically to
-	// their file representation.
-	Cwrite(&fh, sizeof(fh))
+	binary.Write(&coutbuf, binary.LittleEndian, &fh)

	if pe64 != 0 {
-		Cwrite(&oh64, sizeof(oh64))
+		binary.Write(&coutbuf, binary.LittleEndian, &oh64)
	} else {
-		Cwrite(&oh, sizeof(oh))
+		binary.Write(&coutbuf, binary.LittleEndian, &oh)
	}
-	Cwrite(sh, pensect*sizeof(sh[0]))
+	binary.Write(&coutbuf, binary.LittleEndian, sh[:pensect])
}

func strput(s string) {
	coutbuf.w.WriteString(s)
	Cput(0)
	// string must be padded to even size
	if (len(s)+1) % 2 != 0 {
		Cput(0)
	}
}

diff {
-	Cseek(startoff + sizeof(IMAGE_IMPORT_DESCRIPTOR)*(n+1))
+	Cseek(startoff + int64(binary.Size(&IMAGE_IMPORT_DESCRIPTOR{}))*int64(n+1))
}

diff {
-	size = sizeof(e) + 10*nexport + len(outfile) + 1
+	size = binary.Size(&e) + 10*nexport + len(outfile) + 1
}

diff {
-	va_name = va + sizeof(e) + nexport*4
-	va_addr = va + sizeof(e)
-	va_na = va + sizeof(e) + nexport*8
+	va_name = va + binary.Size(&e) + nexport*4
+	va_addr = va + binary.Size(&e)
+	va_na = va + binary.Size(&e) + nexport*8
}

diff {
-	e.Name = va + sizeof(e) + uint32(nexport)*10 // Program names.
+	e.Name = uint32(va + binary.Size(&e)) + uint32(nexport)*10 // Program names.
}

diff {
-	for i = 0; i < sizeof(e); i++ {
-		Cput(uint8((string(&e))[i]))
-	}
+	binary.Write(&coutbuf, binary.LittleEndian, &e)
}

func strtbladd(name string) int {
	off := len(strtbl) + 4 // offset includes 4-byte length at beginning of table
	strtbl = append(strtbl, name...)
	strtbl = append(strtbl, 0)
	return off
}

slice strtbl strtblnextoff strtblsize

diff {
-var strtbl string
+var strtbl []byte
}

diff {
-	Cwrite(rsrcsym.P, int(rsrcsym.Size))
+	Cwrite(rsrcsym.P)
}

diff {
-		fh.SizeOfOptionalHeader = sizeof(oh64)
+		fh.SizeOfOptionalHeader = uint16(binary.Size(&oh64))
}

diff {
-		fh.SizeOfOptionalHeader = sizeof(oh)
+		fh.SizeOfOptionalHeader = uint16(binary.Size(&oh))
}

diff {
-	Binit(&Bso, 1, main.OWRITE)
+	Bso = *Binitw(os.Stdout)
}

slice readsym.data readsym.ndata

diff {
-	rddata(f, &data, &len(data))
+	rddata(f, &data)
}

diff {
-	for i = 1; i < len(argv); i++ {
-		if argv[i] == "-crash_for_testing" {
+	for _, arg := range os.Args {
+		if arg == "-crash_for_testing" {
-			*(*int)(0) = 0
+			*(*int)(nil) = 0
}

diff {
-	main.Flagparse(&len(argv), (**string)(&argv), usage)
+	// Clumsy hack to preserve old behavior of -X taking two arguments.
+	for i := 0; i < len(os.Args); i++ {
+		arg := os.Args[i]
+		if (arg == "--X" || arg == "-X") && i+2 < len(os.Args) {
+			os.Args[i+2] = "-X=VALUE:"+os.Args[i+2]
+			i += 2
+		} else if (strings.HasPrefix(arg, "--X=") || strings.HasPrefix(arg, "-X=")) && i+1 < len(os.Args) {
+			os.Args[i+1] = "-X=VALUE:"+os.Args[i+1]
+			i++
+		}
+	}
+	obj.Flagstr("cpuprofile", "file: write cpu profile to file", &cpuprofile)
+	obj.Flagstr("memprofile", "file: write memory profile to file", &memprofile)
+	obj.Flagparse(usage)
+	startProfile()
}

diff {
-	main.Flagfn2("X", "name value: define string data", addstrdata)
+	main.Flagfn1("X", "name value: define string data", addstrdata1)
}

diff {
+var addstrdata_name string
+func addstrdata1(arg string) {
+	if strings.HasPrefix(arg, "VALUE:") {
+		addstrdata(addstrdata_name, arg[6:])
+	} else {
+		addstrdata_name = arg
+	}
+}
+
func addstrdata(name string, value string) {
}

diff {
-func Ldmain(argv []string) {
+func Ldmain() {
}

bool yy_isalpha.return

diff {
-	struct {
-		name string
-		val  int
-	}{"darwin", Hdarwin},
-	struct {
-		name string
-		val  int
-	}{"dragonfly", Hdragonfly},
-	struct {
-		name string
-		val  int
-	}{"elf", Helf},
-	struct {
-		name string
-		val  int
-	}{"freebsd", Hfreebsd},
-	struct {
-		name string
-		val  int
-	}{"linux", Hlinux},
-	struct {
-		name string
-		val  int
-	}{"android", Hlinux}, // must be after "linux" entry or else headstr(Hlinux) == "android"
-	struct {
-		name string
-		val  int
-	}{"nacl", Hnacl},
-	struct {
-		name string
-		val  int
-	}{"netbsd", Hnetbsd},
-	struct {
-		name string
-		val  int
-	}{"openbsd", Hopenbsd},
-	struct {
-		name string
-		val  int
-	}{"plan9", Hplan9},
-	struct {
-		name string
-		val  int
-	}{"solaris", Hsolaris},
-	struct {
-		name string
-		val  int
-	}{"windows", Hwindows},
-	struct {
-		name string
-		val  int
-	}{"windowsgui", Hwindows},
+	{"darwin", Hdarwin},
+	{"dragonfly", Hdragonfly},
+	{"elf", Helf},
+	{"freebsd", Hfreebsd},
+	{"linux", Hlinux},
+	{"android", Hlinux}, // must be after "linux" entry or else headstr(Hlinux) == "android"
+	{"nacl", Hnacl},
+	{"netbsd", Hnetbsd},
+	{"openbsd", Hopenbsd},
+	{"plan9", Hplan9},
+	{"solaris", Hsolaris},
+	{"windows", Hwindows},
+	{"windowsgui", Hwindows},
}

diff {
-	if len(argv) != 1 {
+	if flag.NArg() != 1 {
		usage()
	}
}

diff {
-	addlibpath(Ctxt, "command line", "command line", argv[0], "main")
+	addlibpath(Ctxt, "command line", "command line", flag.Arg(0), "main")
}

func yy_isalpha(c int) bool {
	return 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z'
}

diff {
-	nuxiinit(arch)
}

diff {
-	if main.Getwd(buf, sizeof(buf)) == 0 {
-		buf = "/???"
-	}
-	if yy_isalpha(int(buf[0])) && buf[1] == ':' {
-		// On Windows.
-		ctxt.Windows = 1
-
-		// Canonicalize path by converting \ to / (Windows accepts both).
-		for p = buf; p[0] != 0; p = p[1:] {
-			if p[0] == '\\' {
-				p[0] = '/'
-			}
-		}
-	}
+	buf, _ = os.Getwd()
+	if buf == "" {
+		buf = "/???"
+	}
+	buf = filepath.ToSlash(buf)
}

slice elfstrdat elfstrsize maxelfstr
slice Elfstrdat elfstrsize maxelfstr

diff {
-var Elfstrdat string
+var Elfstrdat []byte
}

diff {
-	if len(Elfstrdat) == 0 && s[0] != 0 {
+	if len(Elfstrdat) == 0 && s != "" {
}

diff {
+	// Rewrite · to . for ASCII-only tools like DTrace (sigh)
+	s = strings.Replace(s, "·", ".", -1)
+
	n = len(s) + 1
-	if len(Elfstrdat)+n > cap(Elfstrdat) {
+	for len(Elfstrdat)+n > cap(Elfstrdat) {
-		cap(Elfstrdat) = 2 * (len(Elfstrdat) + n + (1 << 20))
-		Elfstrdat = main.Realloc(Elfstrdat, cap(Elfstrdat)).(string)
+		Elfstrdat = append(Elfstrdat[:cap(Elfstrdat)], 0)[:len(Elfstrdat)]
}

diff {
-	len(Elfstrdat) += n
-	main.Memmove(Elfstrdat[off:], s, n)
+	Elfstrdat = Elfstrdat[:off+n]
+	copy(Elfstrdat[off:], s)
}

diff {
-	// replace "·" as ".", because DTrace cannot handle it.
-	p = main.Strstr(s, "·")
-
-	if p != "" {
-		q = Elfstrdat[off:]
-		p = q
-		for q[0] != '\x00' {
-			if uint8(q[0]) == 0xc2 && uint8((q[1:])[0]) == 0xb7 {
-				q = q[2:]
-				p[0] = '.'
-				p = p[1:]
-				len(Elfstrdat)--
-			} else {
-				p[0] = q[0]
-				p = p[1:]
-				q = q[1:]
-			}
-		}
-
-		p[0] = '\x00'
-	}
-
}

diff {
func relocsym(s *LSym) {
	var r *Reloc
	var rs *LSym
	var i16 int16
-	var i int32
	var ri int32
	var off int32
	var siz int32
	var fl int32
	var o int64
-	var cast []byte
}

diff {
func parsepkgdata(file string, pkg string, pp *string, prefixp *string, namep *string, defp *string) int {
	var p string
	var prefix string
	var name string
	var def string
-	var edef string
	var meth string
-	var n int
	var inquote bool
}

diff {
func loadcgo(file string, pkg string, p string) {
	var next string
	var p0 string
	var q string
	var f []string
	var local string
	var remote string
	var lib string
-	var nf int
}

diff {
func ldpe(f *Biobuf, pkg string, length int64, pn string) {
	var err error
	var name string
	var base int32
	var l uint32
	var i int
	var j int
	var numaux int
	var peobj *PeObj
	var sect *PeSect
	var rsect *PeSect
-	var sh IMAGE_SECTION_HEADER
}

diff {
func readpesym(peobj *PeObj, i int, y **PeSym) (err error) {
	var s *LSym
	var sym *PeSym
	var name string
-	var p string
}

diff {
func hostlink() {
	var p string
	var argv []string
-	var c int
	var i int
}

diff {
func ldobj(f *Biobuf, pkg string, length int64, pn string, file string, whence int) {
	var line string
-	var n int
}

diff {
func machoshbits(mseg *MachoSeg, sect *Section, segname string) {
	var msect *MachoSect
	var buf string
-	var p string
}

diff {
func readsym(ctxt *Link, f *Biobuf, pkg string, pn string) {
	var i int
	var j int
	var c int
	var t int
	var v int
	var n int
-	var ndata int
}

diff {
func Ldmain() {
-	var i int
-
}

diff {
func putelfstr(s string) int {
	var off int
	var n int
-	var p string
-	var q string
}

export Arch

diff {
-				ld.Cwrite(ld.Elfstrdat, len(Elfstrdat))
+				ld.Cwrite(ld.Elfstrdat)
}

diff {
-func main(argc int, argv *string) {
+func main() {
	linkarchinit()
-	ld.Ldmain([]string(argc), argv)
+	ld.Ldmain()
}

diff {
-	Hash      [LINKHASH]*LSym
+	Hash      map[symVer]*LSym
}

diff {
	ctxt = new(Link)
+	ctxt.Hash = make(map[symVer]*LSym)
}

func _lookup(ctxt *Link, symb string, v int, creat int) *LSym {
	s := ctxt.Hash[symVer{symb, v}]
	if s != nil {
		return s
	}
	if creat == 0 {
		return nil
	}

	s = linknewsym(ctxt, symb, v)
	s.Extname = s.Name
	ctxt.Hash[symVer{symb, v}] = s
	return s
}

diff {
+type symVer struct {
+	sym string
+	ver int
+}
+
func _lookup(ctxt *Link, symb string, v int, creat int) *LSym {
}

diff {
-		if lib[0] == 0 {
+		if lib == "" {
}

diff {
		p0 = p // save for error message
		f = tokenize(p)
+		if len(f) == 0 {
+			continue
+		}
}

diff {
-	pkg = fmt.Sprintf("%%i", pkg)
+	pkg = pathtoprefix(pkg)
}

diff {
-	for s[0] != 0 {
+	for s != "" {
}

diff {
-	if !strings.HasPrefix("type.", gotype.Name) {
+	if !strings.HasPrefix(gotype.Name, "type.") {
}

diff {
-	for ; n > 0 && s[0] != 0; s = s[1:] {
+	for ; n > 0 && s != ""; s = s[1:] {
}

diff {
-	if gdbscript[0] != '\x00' {
+	if gdbscript != "" {
}

diff {
-			for p = s.Extname; p[0] != 0; p = p[1:] {
+			for p = s.Extname; p != ""; p = p[1:] {
}

diff {
-	return string(r.Sym.P)[r.Add:] // the c-string
+	return cstring(r.Sym.P[r.Add:])
}

diff {
-	if gdbscript[0] != 0 {
+	if gdbscript != "" {
}

diff {
-	for name[0] != 0 {
+	for len(name) != 0 {
}

diff {
-	for cp = name; cp[0] != 0; (func() { h += uint32(cp[0]); cp = cp[1:] })() {
-		h *= 1119
+	for cp = name; cp != ""; cp = cp[1:] {
+		h = h*1119 + uint32(cp[0])
	}
}

diff {
-	for val[0] != '\x00' {
-		if val[1] == '\x00' {
+	for val != "" {
+		if len(val) == 1 {
}

export symaddr addrel symgrow linkarm link386 linkamd64 linkppc64 linkppc64le linkamd64p32 le32 be32 peinit le16 be16 le64 be64 linkrlookup elfwritedynentsymplus wputb
export inuxi4
delete inuxi4

diff {
-			cast = []byte(&o1)
-			for i = 0; i < 4; i++ {
-				s.P[r.Off+4+int32(i)] = cast[ld.Inuxi4[i]]
-			}
+			ld.Ctxt.Arch.ByteOrder.PutUint32(s.P[r.Off:], o1)
}

diff {
-
-			stub.Reachable |= s.Reachable
+			stub.Reachable = stub.Reachable || s.Reachable
}

diff {
-		for r = &s.R[0]; r < s.R[len(s.R):]; r++ {
+		for i = range s.R {
+			r = &s.R[i]
}

diff {
-	var cast []byte
}

diff {
			Diag("%s: malformed archive", file)
+			Errorexit()
}

diff {
-		s.P = s.P[:sect.size]
-		s.Size = int64(len(s.P))
		if sect.flags&0xff == 1 { // S_ZEROFILL
-			s.P = make([]byte, s.Size)
+			s.P = make([]byte, sect.size)
		} else {
-			s.P = dat[sect.addr-c.seg.vmaddr:]
+			s.P = dat[sect.addr-c.seg.vmaddr:][:sect.size]
		}
+		s.Size = int64(len(s.P))
}

diff {
-			elfobj.sect[i].name = string(sect.base)[elfobj.sect[i].nameoff:]
+			elfobj.sect[i].name = cstring(sect.base[elfobj.sect[i].nameoff:])
}

diff {
-var buildinfo = make([]uint8, 32)
+var buildinfo []byte
}

diff {
+		const maxLen = 32
-		if i >= len(buildinfo) {
+		if i >= maxLen {
-			fmt.Fprintf(os.Stderr, "%s: -B option too long (max %d digits): %s\n", main.Argv0, int(len(buildinfo)), ov)
+			fmt.Fprintf(os.Stderr, "%s: -B option too long (max %d digits): %s\n", os.Args[0], maxLen, ov)
}

diff {
-		buildinfo[i] = uint8(b)
+		buildinfo = append(buildinfo, uint8(b))
		i++
}

diff {
-var strtblnextoff int
}
diff {
-var strtblsize int
}

diff {
-			for i = 0; s[i] != 0; i++ {
+			for i = 0; i < len(s); i++ {
}

diff {
+var symbuf []byte
+
func rdsym(ctxt *Link, f *Biobuf, pkg string) *LSym {
}

diff {
-	buf := make([]byte, n)
-	Bread(f, buf)
-	p = string(buf)
+	if len(symbuf) < n {
+		symbuf = make([]byte, n)
+	}
+	Bread(f, symbuf[:n])
+	p = string(symbuf[:n])
}
