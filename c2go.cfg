package src/cmd/ld/* cmd/internal/ld
package src/cmd/6l/* cmd/new6l
package src/cmd/8l/* cmd/new8l
package src/cmd/9l/* cmd/new9l
package src/cmd/5l/* cmd/new5l
package src/liblink/* include/* src/cmd/ld/textflag.h src/runtime/*h internal/libc.h cmd/internal/obj
package src/liblink/*5.c src/cmd/5l/*.out.h cmd/internal/obj/arm
package src/liblink/*6.c src/cmd/6l/*.out.h cmd/internal/obj/x86
package src/liblink/*8.c src/cmd/8l/*.out.h cmd/internal/obj/i386
package src/liblink/*9.c src/cmd/9l/*.out.h cmd/internal/obj/ppc64
package src/liblink/objfilego.c main
package src/cmd/5a/* cmd/new5a
package src/cmd/6a/* cmd/new6a
package src/cmd/8a/* cmd/new8a
package src/cmd/9a/* cmd/new9a
package src/cmd/cc/*body cmd/internal/asm
package src/cmd/gc/* cmd/internal/gc
package src/cmd/5g/* cmd/new5g
package src/cmd/6g/* cmd/new6g
package src/cmd/8g/* cmd/new8g
package src/cmd/9g/* cmd/new9g

delete dnames5 dnames6 dnames8 dnames9
delete emallocz estrdup erealloc

delete find1 nuxiinit fnuxi8 fnuxi4 inuxi1 inuxi2 inuxi4 inuxi8 atolwhex
delete writeobj

# we define our own Biobuf
delete Biobuf

slice LSym.p LSym.np LSym.maxp
slice LSym.r LSym.nr LSym.maxr
slice Link.library Link.libraryp Link.nlibrary
slice Link.libdir Link.nlibdir Link.maxlibdir
slice Arch.typedefs

slice InitPlan.e InitPlan.len InitPlan.cap

bool yy_isalpha.return

ptr bytereg.t
slice doasm.mo

slice Pcdata.p Pcdata.n Pcdata.m

export linkamd64 linkamd64p32 link386 linkarm linkppc64 linkppc64le linknew binitw writeobjdirect linklinehist linknewplist

rename regstr Register
rename anames8 Anames
rename anames6 Anames
rename anames5 Anames
rename anames9 Anames

func Expandpkg(t0 string, pkg string) string {
	return strings.Replace(t0, `"".`, pkg+".", -1)
}

func Symgrow(ctxt *Link, s *LSym, lsiz int64) {
	var siz int
	siz = int(lsiz)
	if int64(siz) != lsiz {
		log.Fatal("Symgrow size %d too long", lsiz)
	}
	if len(s.P) >= siz {
		return
	}
	for cap(s.P) < siz {
		s.P = append(s.P[:cap(s.P)], 0)
	}
	s.P = s.P[:siz]
}

func savedata(ctxt *Link, s *LSym, p *Prog, pn string) {
	off := int32(p.From.Offset)
	siz := int32(p.From3.Offset)
	if off < 0 || siz < 0 || off >= 1<<30 || siz >= 100 {
		mangle(pn)
	}
	if ctxt.Enforce_data_order != 0 && off < int32(len(s.P)) {
		ctxt.Diag("data out of order (already have %d)\n%P", len(s.P), p)
	}
	Symgrow(ctxt, s, int64(off+siz))
	
	switch int(p.To.Type) {
	default:
		ctxt.Diag("bad data: %P", p)

	case TYPE_FCONST:
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte floating point constant", siz)
		
		case 4:
			flt := math.Float32bits(float32(p.To.U.Dval))
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], flt)
		
		case 8:
			flt := math.Float64bits(p.To.U.Dval)
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], flt)
		}

	case TYPE_SCONST:
		copy(s.P[off:off+siz], p.To.U.Sval)
	
	case TYPE_CONST, TYPE_ADDR:
		if p.To.Sym != nil || int(p.To.Type) == TYPE_ADDR {
			r := Addrel(s)
			r.Off = off
			r.Siz = uint8(siz)
			r.Sym = p.To.Sym
			r.Type = R_ADDR
			r.Add = p.To.Offset
			break
		}
		o := p.To.Offset
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte integer constant", siz)
		case 1:
			s.P[off] = byte(o)
		case 2:
			ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(o))
		case 4:
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(o))
		case 8:
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(o))
		}
	}	
}

func Addrel(s *LSym) *Reloc {
	s.R = append(s.R, Reloc{})
	return &s.R[len(s.R)-1]
}

export setuintxx

func Setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
	if s.Type == 0 {
		s.Type = SDATA
	}
	s.Reachable = 1
	if s.Size < off+wid {
		s.Size = off + wid
		Symgrow(ctxt, s, s.Size)
	}

	switch wid {
	case 1:
		s.P[off] = uint8(v)
	case 2:
		ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(v))
	case 4:
		ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(v))
	case 8:
		ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(v))
	}
	
	return off+wid
}

diff {
type LinkArch struct {
+	ByteOrder	binary.ByteOrder
}
diff {
type LinkArch struct {
+	Rconv func(int) string
}
diff {
type LinkArch struct {
+	Dconv func(*Prog, int, *Addr) string
}

func addlib(ctxt *Link, src, obj, pathname string) {
	name := path.Clean(pathname)

	// runtime.a -> runtime
	short := strings.TrimSuffix(name, ".a")

	// already loaded?
	for i := range ctxt.Library {
		if ctxt.Library[i].Pkg == short {
			return
		}
	}

	var pname string
	// runtime -> runtime.a for search
	if (!(ctxt.Windows != 0) && name[0] == '/') || (ctxt.Windows != 0 && name[1] == ':') {
		pname = name
	} else {
		// try dot, -L "libdir", and then goroot.
		for _, dir := range ctxt.Libdir {
			pname = dir + "/" + name
			if _, err := os.Stat(pname); !os.IsNotExist(err) {
				break
			}
		}
	}
	pname = path.Clean(pname)

	// runtime.a -> runtime
	pname = strings.TrimSuffix(pname, ".a")

	if ctxt.Debugvlog > 1 && ctxt.Bso != nil {
		fmt.Fprintf(ctxt.Bso, "%5.2f addlib: %s %s pulls in %s\n", Cputime(), obj, src, pname)
	}
	Addlibpath(ctxt, src, obj, pname, name)
}

func Addlibpath(ctxt *Link, srcref, objref, file, pkg string) {
	for _, lib := range ctxt.Library {
		if lib.File == file {
			return
		}
	}
	
	if ctxt.Debugvlog > 1 && ctxt.Bso != nil {
		fmt.Fprintf(ctxt.Bso, "%5.2f addlibpath: srcref: %s objref: %s file: %s pkg: %s\n", Cputime(), srcref, objref, file, pkg)
	}

	ctxt.Library = append(ctxt.Library, Library{
		Objref: objref,
		Srcref: srcref,
		File: file,
		Pkg: pkg,
	})
}

diff {
func Copyp(ctxt *Link, q *Prog) *Prog {
}

export linklinefmt
diff {
-func linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
+func Linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
}

func linklinefmt(ctxt *Link, lno0 int, showAll, showFullPath bool) string {
	var a [HISTSZ]struct {
		incl *Hist
		idel int32
		line *Hist
		ldel int32
	}
	lno := int32(lno0)
	lno1 := lno
	var d int32
	var i int
	var n int
	var h *Hist
	n = 0
	var fp string
	for h = ctxt.Hist; h != nil; h = h.Link {
		if h.Offset < 0 {
			continue
		}
		if lno < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset > 0 {
				// #line directive
				if n > 0 && n < int(HISTSZ) {
					a[n-1].line = h
					a[n-1].ldel = h.Line - h.Offset + 1
				}
			} else {
				// beginning of file
				if n < int(HISTSZ) {
					a[n].incl = h
					a[n].idel = h.Line
					a[n].line = nil
				}
				n++
			}
			continue
		}
		n--
		if n > 0 && n < int(HISTSZ) {
			d = h.Line - a[n].incl.Line
			a[n-1].ldel += d
			a[n-1].idel += d
		}
	}
	if n > int(HISTSZ) {
		n = int(HISTSZ)
	}
	for i = n - 1; i >= 0; i-- {
		if i != n-1 {
			if !showAll {
				break
			}
			fp += " "
		}
		if ctxt.Debugline != 0 || showFullPath {
			fp += fmt.Sprintf("%s/", ctxt.Pathname)
		}
		if a[i].line != nil {
			fp += fmt.Sprintf("%s:%d[%s:%d]", a[i].line.Name, lno-a[i].ldel+1, a[i].incl.Name, lno-a[i].idel+1)
		} else {
			fp += fmt.Sprintf("%s:%d", a[i].incl.Name, lno-a[i].idel+1)
		}
		lno = a[i].incl.Line - 1 // now print out start of this file
	}
	if n == 0 {
		fp += fmt.Sprintf("<unknown line number %d %d %d %s>", lno1, ctxt.Hist.Offset, ctxt.Hist.Line, ctxt.Hist.Name)
	}
	return fp
}

func haspathprefix(s string, t string) bool {
	var i int
	var cs int
	var ct int
	if len(t) > len(s) {
		return false
	}
	for i = 0; i < len(t); i++ {
		cs = int(s[i])
		ct = int(t[i])
		if 'A' <= cs && cs <= 'Z' {
			cs += 'a' - 'A'
		}
		if 'A' <= ct && ct <= 'Z' {
			ct += 'a' - 'A'
		}
		if cs == '\\' {
			cs = '/'
		}
		if ct == '\\' {
			ct = '/'
		}
		if cs != ct {
			return false
		}
	}
	return i >= len(s) || s[i] == '/' || s[i] == '\\'
}

func linkgetline(ctxt *Link, line int32, f **LSym, l *int32) {
	var a [HISTSZ]struct {
		incl *Hist
		idel int32
		line *Hist
		ldel int32
	}
	var lno int32
	var d int32
	var dlno int32
	var n int
	var h *Hist
	var buf string
	var buf1 string
	var file string
	lno = int32(line)
	n = 0
	for h = ctxt.Hist; h != nil; h = h.Link {
		if h.Offset < 0 {
			continue
		}
		if lno < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset > 0 {
				// #line directive
				if n > 0 && n < HISTSZ {
					a[n-1].line = h
					a[n-1].ldel = h.Line - h.Offset + 1
				}
			} else {
				// beginning of file
				if n < HISTSZ {
					a[n].incl = h
					a[n].idel = h.Line
					a[n].line = nil
				}
				n++
			}
			continue
		}
		n--
		if n > 0 && n < HISTSZ {
			d = h.Line - a[n].incl.Line
			a[n-1].ldel += d
			a[n-1].idel += d
		}
	}
	if n > HISTSZ {
		n = HISTSZ
	}
	if n <= 0 {
		*f = Linklookup(ctxt, "??", HistVersion)
		*l = 0
		return
	}
	n--
	if a[n].line != nil {
		file = a[n].line.Name
		dlno = a[n].ldel - 1
	} else {
		file = a[n].incl.Name
		dlno = a[n].idel - 1
	}
	if (ctxt.Windows == 0 && file[0] == '/') || (ctxt.Windows != 0 && file[1] == ':') || file[0] == '<' {
		buf = fmt.Sprintf("%s", file)
	} else {
		buf = fmt.Sprintf("%s/%s", ctxt.Pathname, file)
	}
	// Remove leading ctxt->trimpath, or else rewrite $GOROOT to $GOROOT_FINAL.
	if ctxt.Trimpath != "" && haspathprefix(buf, ctxt.Trimpath) {
		if len(buf) == len(ctxt.Trimpath) {
			buf = "??"
		} else {
			buf1 = fmt.Sprintf("%s", buf[len(ctxt.Trimpath)+1:])
			if buf1[0] == '\x00' {
				buf1 = "??"
			}
			buf = buf1
		}
	} else if ctxt.Goroot_final != "" && haspathprefix(buf, ctxt.Goroot) {
		buf1 = fmt.Sprintf("%s%s", ctxt.Goroot_final, buf[len(ctxt.Goroot):])
		buf = buf1
	}
	lno -= dlno
	*f = Linklookup(ctxt, buf, HistVersion)
	*l = lno
}

func linkprfile(ctxt *Link, line int) {
	l := int32(line)
	var i int
	var n int
	var a [HISTSZ]Hist
	var h *Hist
	var d int32
	n = 0
	for h = ctxt.Hist; h != nil; h = h.Link {
		if l < h.Line {
			break
		}
		if h.Name != "<pop>" {
			if h.Offset == 0 {
				if n >= 0 && n < HISTSZ {
					a[n] = *h
				}
				n++
				continue
			}
			if n > 0 && n < HISTSZ {
				if a[n-1].Offset == 0 {
					a[n] = *h
					n++
				} else {
					a[n-1] = *h
				}
			}
			continue
		}
		n--
		if n >= 0 && n < HISTSZ {
			d = h.Line - a[n].Line
			for i = 0; i < n; i++ {
				a[i].Line += d
			}
		}
	}
	if n > HISTSZ {
		n = HISTSZ
	}
	for i = 0; i < n; i++ {
		fmt.Printf("%s:%d ", a[i].Name, int(l-a[i].Line+a[i].Offset+1))
	}
}

func wrdata(b *Biobuf, v []byte) {
	wrint(b, int64(len(v)))
	Bwrite(b, v)
}

func wrstring(b *Biobuf, s string) {
	wrint(b, int64(len(s)))
	b.w.WriteString(s)
}

func wrpath(ctxt *Link, b *Biobuf, p string) {
	wrstring(b, filepath.ToSlash(p))
}

func wrint(b *Biobuf, sval int64) {
	var uv uint64
	var v uint64
	var buf [10]uint8
	var p []uint8
	uv = (uint64(sval) << 1) ^ uint64(int64(sval>>63))
	p = buf[:]
	for v = uv; v >= 0x80; v >>= 7 {
		p[0] = uint8(v | 0x80)
		p = p[1:]
	}
	p[0] = uint8(v)
	p = p[1:]
	Bwrite(b, buf[:len(buf)-len(p)])
}

slice Pcln.funcdata Pcln.nfuncdata Pcln.mfuncdata
slice Pcln.pcdata Pcln.npcdata Pcln.mpcdata
slice Pcln.file Pcln.nfile Pcln.mfile
slice Pcln.funcdataoff Pcln.nfuncdata

func addvarint(ctxt *Link, d *Pcdata, val uint32) {
	var v uint32
	for v = val; v >= 0x80; v >>= 7 {
		d.P = append(d.P, uint8(v|0x80))
	}
	d.P = append(d.P, uint8(v))
}

diff {
-	for i = 0; i < int32(len(pcln.File)); i++ {
-		if pcln.File[i] == f {
-			pcln.Lastfile = f
-			pcln.Lastindex = int(i)
-			return i
-		}
-	}
-
-	if len(pcln.File) >= cap(pcln.File) {
-		cap(pcln.File) = (len(pcln.File) + 1) * 2
-		pcln.File = erealloc(pcln.File, cap(pcln.File)*sizeof(pcln.File[0])).([]*LSym)
-	}
-
-	pcln.File[len(pcln.File)] = f
-	len(pcln.File)++
+	for i = 0; i < int32(len(pcln.File)); i++ {
+		file := pcln.File[i]
+		if file == f {
+			pcln.Lastfile = f
+			pcln.Lastindex = int(i)
+			return int32(i)
+		}
+	}
+	pcln.File = append(pcln.File, f)
}
diff {
-	var n int
-	var havepc *uint32
-	var havefunc *uint32
}
diff {
-	n = ((npcdata+31)/32 + (nfuncdata+31)/32) * 4
-
-	havepc = (*uint32)(make([]byte, n))
-	havefunc = havepc + (npcdata+31)/32
+	havepc := make([]uint32, (npcdata+31)/32)
+	havefunc := make([]uint32, (nfuncdata+31)/32)
}

func yy_isalpha(c int) bool {
	return 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z'
}
diff {
-	nuxiinit(arch)
}
diff {
-	ctxt.Goroot_final = Getenv("GOROOT_FINAL")
-	if ctxt.Goroot_final != "" && ctxt.Goroot_final[0] == '\x00' {
-		ctxt.Goroot_final = ""
-	}
+	ctxt.Goroot_final = os.Getenv("GOROOT_FINAL")
}
diff {
-	p = obj.Getgoarch()
+	p = Getgoarch()
}
diff {
-	if getwd(buf, sizeof(buf)) == 0 {
-		buf = "/???"
-	}
-	if yy_isalpha(int(buf[0])) && buf[1] == ':' {
-		// On Windows.
-		ctxt.Windows = 1
-
-		// Canonicalize path by converting \ to / (Windows accepts both).
-		for p = buf; p[0] != 0; p = p[1:] {
-			if p[0] == '\\' {
-				p[0] = '/'
-			}
-		}
-	}
+	buf, _ = os.Getwd()
+	if buf == "" {
+		buf = "/???"
+	}
+	buf = filepath.ToSlash(buf)
}

export linksymfmt
func Linksymfmt(s *LSym) string {
	if s == nil {
		return "<nil>"
	}
	return s.Name
}

slice asmoutnacl.out
slice asmout.out

bool immfloat.return
bool immhalf.return
bool cmp.return
bool isdata.return
bool iscall.return
bool LinkArch.iscall.return
bool LinkArch.isdata.return

diff {
-			xcmp[i][n] = uint8(bool2int(cmp(n, i)))
+			if cmp(n, i) {
+				xcmp[i][n] = 1
+			}
}

diff {
-			fmt.Fprintf(ctxt.Bso, "%5.2f span1\n", obj.Cputime())
+			fmt.Fprintf(ctxt.Bso, "%5.2f span1\n", obj.Cputime())
}

slice oplook.o
slice oplook.e
slice Oprang.start
slice Oprang.stop

delete listinit5 listinit6 listinit8 listinit9

diff {
-		op = string(&"<<>>->@>"[((v>>5)&3)<<1])
+		op = string("<<>>->@>"[((v>>5)&3)<<1:])
}

delete DSconv

diff {
type Prog struct {
+	Ctxt *Link
}

diff {
type LinkArch struct {
+	Pconv func(*Prog) string
}

diff {
= obj.LinkArch{
+	Pconv: Pconv,
}

diff {
amd64 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
amd64p32 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
arm = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
386 = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
ppc64 = obj.LinkArch{
+	ByteOrder: binary.BigEndian,
}
diff {
ppc64le = obj.LinkArch{
+	ByteOrder: binary.LittleEndian,
}
diff {
= obj.LinkArch{
+	Rconv: Rconv,
}
diff {
= obj.LinkArch{
+	Dconv: Dconv,
}

diff {
-		obj.Memmove(p, nop[m-1], m)
+		copy(p[:m], nop[m-1][:m])
}
diff {
-			obj.Memmove(s.P[p.Pc:], ctxt.And, m)
+			copy(s.P[p.Pc:][:m], ctxt.And[:m])
}

# TODO(rsc): Why does len rewrite not catch this?
diff {
-	wrdata(b, s.P, len(s.P))
+	wrdata(b, s.P)
}

diff {
-		obj.Memmove(and0[np+1:], and0[np:], n-np)
+		copy(and0[np+1:], and0[np:n])
}

diff {
-		fmt.Fprintf(ctxt.Bso, "%5.2f noops\n", obj.Cputime())
+		fmt.Fprintf(ctxt.Bso, "%5.2f noops\n", obj.Cputime())
}
diff {
-			cast = []byte(&out[i])
-			for j = 0; j < 4; j++ {
-				bp[0] = cast[obj.Inuxi4[j]]
-				bp = bp[1:]
-			}
+			ctxt.Arch.ByteOrder.PutUint32(bp, out[i])
+			bp = bp[4:]
}
diff {
	var i int32
-	var j int32
	var bp []byte
-	var cast []byte
}

diff {
-	var p string
	var h uint32
-	var c int

	h = uint32(v)
-	for p = symb; ; p = p[1:] {
-		c = int(p[0])
-		if !(c != 0) {
-			break
-		}
+	for i := 0; i < len(symb); i++ {
+		c := int(symb[i])
}
diff {
-	StackPreempt = 1
+	StackPreempt = -1314 // 0xfff...fade
}
diff {
-		p.From.Offset = int64(uint32(obj.StackPreempt))
+		p.From.Offset = int64(uint32(obj.StackPreempt & (1<<32-1)))
}
diff {
-		p.To.Offset = int64(uint32(obj.StackPreempt))
+		p.To.Offset = int64(uint32(obj.StackPreempt & (1<<32-1)))
}
diff {
-	if (ctxt.Windows == 0 && file[0] == '/') || (ctxt.Windows != 0 && file[1] == ':') || file[0] == '<' {
+	if filepath.IsAbs(file) || strings.HasPrefix(file, "<") {
}
diff {
-	p = Getgoarch()
-	if p != arch.Name {
-		log.Fatalf("invalid goarch %s (want %s)", p, arch.Name)
-	}
-
}

# export linkprfile via diff, because it was supplied as a func above.
# the matching for the func doesn't work right if you say func Linkprfile,
# but the func overrides any 'export linkprfile'.
diff {
-func linkprfile(ctxt *Link, line int) {
+func Linkprfile(ctxt *Link, line int) {
}

func prg() *obj.Prog {
	p := zprg
	return &p
}

diff {
-	Exits("unknown experiment")
+	os.Exit(2)
}

func linksetexp() {
	for _, f := range strings.Split(goexperiment, ",") {
		if f != "" {
			addexp(f)
		}
	}
}

export expstring
func Expstring() string {
	buf := "X"
	for i := range exper {
		if *exper[i].val != 0 {
			buf += "," + exper[i].name
		}
	}
	if buf == "X" {
		buf += ",none"
	}
	return "X:" + buf[2:]
}

diff {
-			ctxt.Diag("argument %v is TYPE_CONST, should be TYPE_ADDR, in %v", Dconv(p, 0, a), p)
+			ctxt.Diag("argument is TYPE_CONST, should be TYPE_ADDR, in %v", p)
}

diff {
-			ctxt.Diag("argument %v is TYPE_ADDR, should be TYPE_CONST, in %v", Dconv(p, 0, a), p)
+			ctxt.Diag("argument is TYPE_ADDR, should be TYPE_CONST, in %v", p)
}

diff {
-	ctxt.Diag("invalid encoding for argument %v in %v", Dconv(p, 0, a), p)
+	ctxt.Diag("invalid encoding for argument %v", p)
}

diff {
-	ArgsSizeUnknown            = 0x80000000
+	ArgsSizeUnknown            = -0x80000000
}

diff {
-new(Prog)
+ctxt.NewProg()
}
diff {
-				if str[0] == 0 {
+				if str == "" {
					str += "[R"
}

# compiler starts roughly here

diff {
-	b [XXX]uint32
+	b []uint32
}

func bvalloc(n int32) *Bvec {
	return &Bvec{n, make([]uint32, bvsize(uint32(n))/4)}
}

diff {
-	return obj.Memcmp(bv1.b, bv2.b, int(nbytes))
+	for i, x := range bv1.b {
+		if x != bv2.b[i] {
+			return 1
+		}
+	}
+	return 0
}

diff {
-	obj.Memmove(dst.b, src.b, bvsize(uint32(dst.n)))
+	for i, x := range src.b {
+		dst.b[i] = x
+	}
}

diff {
-	obj.Memset(bv.b, 0x00, bvsize(bv.n))
+	for i := range bv.b {
+		bv.b[i] = 0
+	}
}

diff {
- indent((*obj.Fmt)(fp))
+ fp = indent(fp)
}

func indent(s string) string {
	return s + "\n" + strings.Repeat(".   ", dumpdepth)
}

slice dotoffset.oary

delete DEFAULTCAPACITY arraynew arrayfree arraylength arrayget arrayset ensurecapacity arrayadd arraysort

slice Liveness.uevar
slice Liveness.varkill
slice Liveness.livein
slice Liveness.liveout
slice Liveness.avarinit
slice Liveness.avarinitany
slice Liveness.avarinitall
slice inithash.autohash inithash.nautohash
slice indexdup.hash indexdup.nhash
slice keydup.hash keydup.nhash
slice fielddup.hash fielddup.nhash
slice typecheckcomplit.hash typecheckcomplit.nhash

diff {
-func vmkcall(fn *Node, t *Type, init **NodeList, va []interface{}) *Node {
+func vmkcall(fn *Node, t *Type, init **NodeList, va []*Node) *Node {
}

diff {
	for i = 0; i < n; i++ {
-		args = list(args, va_arg(va, *Node))
+		args = list(args, va[i])
}

func mkcall(name string, t *Type, init **NodeList, args ...*Node) *Node {
	return vmkcall(syslook(name, 0), t, init, args)
}

func mkcall1(fn *Node, t *Type, init **NodeList, args ...*Node) *Node {
	return vmkcall(fn, t, init, args)
}

diff {
- hash = hash[:inithash(n, (***Node)(&hash), autohash[:])]
+ hash = inithash(n, autohash[:])
}

diff {
- func inithash(n *Node, hash ***Node, autohash []*Node) uint32 {
+ func inithash(n *Node, autohash []*Node) []*Node {
}
diff {
-		*hash = &autohash[0]
-		for i = 0; i < len(autohash); i++ {
-			(*hash)[i] = nil
-		}
-		return uint32(len(autohash))
+		for i := range autohash {
+			autohash[i] = nil
+		}
+		return autohash
}
diff {
	// build and return a throw-away hash table
-	*hash = make([]*Node, h)
-
-	for i = 0; i < h; i++ {
-		(*hash)[i] = nil
-	}
-	return h
+	return make([]*Node, h)
}
diff {
-		s = string(&d)
-		b = 0
-		for i = sizeof(d); i > 0; i-- {
-			b = b*PRIME1 + uint32(s[0])
-			s = s[1:]
-		}
+		x := math.Float64bits(d)
+		for i := 0; i < 8; i++ {
+			b = b*PRIME1 + uint32(x&0xFF)
+			x >>= 8
+		}
}

diff {
func onearg(n *Node, f string, args ...interface{}) int {
-	var arg []interface{}
}
diff {
-		obj.Va_start(arg, f)
-		p = obj.Vsmprint(f, arg)
-		obj.Va_end(arg)
+		p = fmt.Sprintf(f, args...)
}

diff {
-		if descbuf < sizeof(descbuf) {
			desc = descbuf
-		} else {
-			desc = "function argument"
-		}
}

slice postorder.rpo2r
slice flowrpo.rpo2r
slice rpolca.idom
slice loophead.idom
slice flowrpo.idom
slice doms.idom
slice Graph.rpo
slice InitPlan.e
slice err nerr merr
rename err errors
slice ispkgin.pkgs ispkgin.n
slice mergetemp.var mergetemp.nvar
rename append walkappend

func stringtoarraylit(np **Node) {
	n := *np
	if n.Left.Op != OLITERAL || n.Left.Val.Ctype != CTSTR {
		Fatal("stringtoarraylit %N", n)
	}

	s := n.Left.Val.U.Sval.S
	var l *NodeList
	if n.Type.Type.Etype == TUINT8 {
		// []byte
		for i := 0; i < len(s); i++ {
			l = list(l, Nod(OKEY, Nodintconst(int64(i)), Nodintconst(int64(s[0]))))
		}
	} else {
		// []rune
		i := 0
		for _, r := range s {
			l = list(l, Nod(OKEY, Nodintconst(int64(i)), Nodintconst(int64(r))))
			i++
		}
	}

	nn := Nod(OCOMPLIT, nil, typenod(n.Type))
	nn.List = l
	typecheck(&nn, Erv)
	*np = nn
}
diff {
-func sprint_depchain(fmt_ *obj.Fmt, stack *NodeList, cur *Node, first *Node) {
+func sprint_depchain(fmt_ *string, stack *NodeList, cur *Node, first *Node) {
}
diff {
-			fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), Nconv(l.N, 0), Nconv(cur, 0))
+			*fmt_ += fmt.Sprintf("\n\t%v: %v uses %v", l.N.Line(), Nconv(l.N, 0), Nconv(cur, 0))
}
diff {
-			sprint_depchain((*obj.Fmt)(&fmt_), typecheck_tcstack, n, n)
+			sprint_depchain(&fmt_, typecheck_tcstack, n, n)
}

func newstrlit(s string) *Strlit {
	return &Strlit{
		S: s,
	}
}

func pathtoprefix(s string) string {
	slash := strings.LastIndex(s, "/")
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			goto escape
		}
	}
	return s

escape:
	var buf bytes.Buffer
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c <= ' ' || i >= slash && c == '.' || c == '%' || c == '"' || c >= 0x7F {
			fmt.Fprintf(&buf, "%%%02x", c)
			continue
		}
		buf.WriteByte(c)
	}
	return buf.String()
}

diff {
-		n.List = (*NodeList)(1)
+		n.List = nil
}

bool eqnote.return

func eqnote(a, b *Strlit) bool {
	return a == b || a != nil && b != nil && a.S == b.S
}

delete remal mal

diff {
-	s.Name = string(make([]byte, obj.Strlen(name)+1))
}

func entry(p *InitPlan) *InitEntry {
	p.E = append(p.E, InitEntry{})
	return &p.E[len(p.E)-1]
}

diff {
-	obj.Va_start(arg, fmt_)
-	obj.Vfprint(1, fmt_, arg)
-	obj.Va_end(arg)
+	fmt.Printf(fmt_, args...)
}
diff {
func Fatal(fmt_ string, args ...interface{}) {
-	var arg []interface{}
}

diff {
-	var arg []interface{}
-
-	obj.Va_start(arg, fmt_)
-	adderr(line, fmt_, arg)
-	obj.Va_end(arg)
+	adderr(line, fmt_, args)
}

diff {
-	obj.Va_start(arg, fmt_)
-	adderr(parserline(), fmt_, arg)
-	obj.Va_end(arg)
+	adderr(parserline(), fmt_, args)
}

diff {
func Yyerror(fmt_ string, args ...interface{}) {
	var i int
-	var arg []interface{}
}

func adderr(line int, format string, args []interface{}) {
	errors = append(errors, Error{
		seq: len(errors),
		lineno: line,
		msg: fmt.Sprintf("%v: %s\n", Ctxt.Line(line), fmt.Sprintf(format, args...)),
	})
}

delete ucistrcmp

diff {
-	if strings.HasPrefix(obj.Getgoversion(), "release") {
+	if strings.HasPrefix(obj.Getgoversion(), "release") {
}

diff {
-			obj.Strecpy(buf, buf[sizeof(buf):], fmt_)
-
-			p = obj.Strstr(buf, "{ or {")
-			if p != "" {
-				obj.Memmove(p[1:], p[6:], len(p+6)+1)
-			}
-
-			// The grammar has ? and @ but only for reading imports.
-			// Silence them in ordinary errors.
-			p = obj.Strstr(buf, " or ?")
-
-			if p != "" {
-				obj.Memmove(p, p[5:], len(p+5)+1)
-			}
-			p = obj.Strstr(buf, " or @")
-			if p != "" {
-				obj.Memmove(p, p[5:], len(p+5)+1)
-			}
-			fmt_ = buf
+			// The grammar has ? and @ but only for reading imports.
+			// Silence them in ordinary errors.
+			fmt_ = strings.Replace(fmt_, "{ or {", "{", -1)
+			fmt_ = strings.Replace(fmt_, " or ?", "", -1)
+			fmt_ = strings.Replace(fmt_, " or @", "", -1)
}

diff {
-		*(*int)(0) = 0
+		var x *int
+		*x = 0
}
diff {
-obj.Remove(outfile)
+os.Remove(outfile)
}
diff {
-obj.Exits("error")
+os.Exit(2)
}

diff {
- obj.Atoi(note.S[4:])
+ atoi(note.S[4:])
}

diff {
- uint32(^0)
+ ^uint32(0)
}
diff {
-	obj.Snprint(namebuf, sizeof(namebuf), namefmt, makefuncdatasym_nsym)
+	namebuf = fmt.Sprintf(namefmt, makefuncdatasym_nsym)
}
diff {
-	b = obj.Bopen(asmhdr, obj.OWRITE)
-	if b == nil {
-		Fatal("open %s: %v", asmhdr, err)
-	}
+	b, err := obj.Bopenw(asmhdr)
+	if err != nil {
+		Fatal("%v", err)
+	}
}

bool exportname.return
func exportname(s string) bool {
	if s[0] < utf8.RuneSelf {
		return 'A' <= s[0] && s[0] <= 'Z'
	}
	r, _ := utf8.DecodeRuneInString(s)
	return unicode.IsUpper(r)
}

diff {
-	if strings.ContainsRune(s.Name, CenterDot) {
-		name = s.Name
-		main.Utfrune(name, CenterDot) = ""
-	}
+	if i := strings.Index(s.Name, string(CenterDot)); i >= 0 {
+		name = s.Name[:i]
+	}
}
diff {
-					obj.Memmove(str.S[len:], nr.Val.U.Sval.S, len(nr.Val.U.Sval.S))
+					str.S += nr.Val.U.Sval.S
}
func cmpslit(l, r *Node) int {
	return stringsCompare(l.Val.U.Sval.S, r.Val.U.Sval.S)
}

func islocalname(name *Strlit) bool {
	return strings.HasPrefix(name.S, "/") ||
		Ctxt.Windows != 0 && len(name.S) >= 3 && yy_isalpha(int(name.S[0])) && name.S[1] == ':' && name.S[2] == '/' ||
		strings.HasPrefix(name.S, "./") || name.S == "." ||
		strings.HasPrefix(name.S, "../") || name.S == ".."
}

bool islocalname.return

diff {
-		l = main.Runelen(rune_)
-		s = (*Strlit)(make([]byte, sizeof(*s)+l))
-		s.S = s.S[:l]
-		main.Runetochar(string(s.S), &rune_)
+		s = &Strlit{S: string(rune_)}
}

diff {
-func getvariables(fn *Node) *Array {
-	var result *Array
+func getvariables(fn *Node) []*Node {
+	var result []*Node
}
diff {
-func newcfg(firstp *obj.Prog) *Array {
+func newcfg(firstp *obj.Prog) []*BasicBlock {
}
diff {
-var selectgo *Array
+var selectgo []*BasicBlock
}
diff {
-	return (*Array)(cfg)
+	return cfg
}
diff {
-func newliveness(fn *Node, ptxt *obj.Prog, cfg *Array, vars *Array) *Liveness {
+func newliveness(fn *Node, ptxt *obj.Prog, cfg []*BasicBlock, vars []*Node) *Liveness {
}
diff {
-	var cfg *Array
+	var cfg []*BasicBlock
}
diff {
-	var vars *Array
+	var vars []*Node
}
diff {
-	arraysort((*Array)(cfg), blockrpocmp)
+	sort.Sort(blockrpocmp(cfg))
}
diff {
-func blockrpocmp(p1 interface{}, p2 interface{}) int {
-	var bb1 *BasicBlock
-	var bb2 *BasicBlock
-
-	bb1 = *p1.(**BasicBlock)
-	bb2 = *p2.(**BasicBlock)
-	if bb1.rpo < bb2.rpo {
-		return -1
-	}
-	if bb1.rpo > bb2.rpo {
-		return 1
-	}
-	return 0
-}
+type blockrpocmp []*BasicBlock
+func (x blockrpocmp) Len() int { return len(x) }
+func (x blockrpocmp) Swap(i, j int) { x[i], x[j] = x[j], x[i]}
+func (x blockrpocmp) Less(i, j int) bool { return x[i].rpo < x[j].rpo }
}

rename twobitwritesymbol.len n

diff {
-	obj.Memset(remap, 0xff, n*sizeof(remap[0]))
+	for i := range remap {
+		remap[i] = -1
+	}
}

diff {
-	obj.Memset(table, 0xff, tablesize*sizeof(table[0]))
+	for i := range table {
+		table[i] = -1
+	}
}

bool isfunny.return
func isfunny(n *Node) bool {
	return n.Sym != nil && (n.Sym.Name == ".fp" || n.Sym.Name == ".args")
}

rename freecfg.len n

diff {
- cfg = append(cfg, p.Link.Opt)
+ cfg = append(cfg, p.Link.Opt.(*BasicBlock))
}
diff {
- cfg = append(cfg, p.To.U.Branch.Opt)
+ cfg = append(cfg, p.To.U.Branch.Opt.(*BasicBlock))
}
diff {
- Fatal("bad bookkeeping in liveness %v %d", Nconv(to.Node, 0), pos)
+ Fatal("bad bookkeeping in liveness %v %d", Nconv(to.Node.(*Node), 0), pos)
}
diff {
- Fatal("bad bookkeeping in liveness %v %d", Nconv(from.Node, 0), pos)
+ Fatal("bad bookkeeping in liveness %v %d", Nconv(from.Node.(*Node), 0), pos)
}

diff {
-		mphextofix(&a.Val, start, -cap(s)+cap(start))
+		mphextofix(&a.Val, start)
}

diff {
-	mphextofix(a, s0, -cap(s)+cap(s0))
+	mphextofix(a, s0)
}

diff {
-func mphextofix(a *Mpint, s string, n int) {
+func mphextofix(a *Mpint, s string) {
}
diff {
-	for s[0] == '0' {
+	for s != "" && s[0] == '0' {
		s = s[1:]
-		n--
}
diff {
-	if 4*n > Mpscale*Mpprec {
+	if 4*len(s) > Mpscale*Mpprec {
}
diff {
-	end = n - 1
+	end = len(s) - 1
	for hexdigitp = end; hexdigitp >= 0; hexdigitp-- {
}

diff {
-			if dp-ex >= 1<<(8*sizeof(dp)-3) || int(int16(4*(dp-ex))) != 4*(dp-ex) {
+			if dp-ex >= 1<<(32-3) || int(int16(4*(dp-ex))) != 4*(dp-ex) {
}
diff {
func Bconv(xval *Mpint, flag int) string {
-	var buf string
+	var buf [500]byte
}
diff {
-	p = sizeof(buf)
-	p--
-	buf[p] = 0
+	p = len(buf)
}
diff {
-	fp += &buf[p]
+	fp += string(buf[p:])
}
diff {
-		d *= obj.Pow(10, dexp-float64(exp))
+		d *= math.Pow(10, dexp-float64(exp))
}
diff {
-	f = obj.Ldexp(f, e)
+	f = math.Ldexp(f, e)
}
diff {
-	f = obj.Frexp(c, &i)
+	f, i = math.Frexp(c)
}
diff {
-		l = int(obj.Floor(f))
+		l = int(math.Floor(f))
}

export ctxt
delete Lconv

diff {
-		if 0 <= x && x <= main.Runemax {
+		if 0 <= x && x <= utf8.MaxRune {
}
diff {
-		case main.Runeerror:
+		case utf8.RuneError:
}
diff {
func Zconv(sp *Strlit, flag int) string {
-	var r uint
}
diff {
-	s = sp.S
-	se = s[len(sp.S):]
-
	// NOTE: Keep in sync with ../ld/go.c:/^Zconv.
-	for s < se {
-		n = main.Chartorune(&r, s)
-		s = s[n:]
+	s = sp.S
+	for i := 0; i < len(s); i += n {
+		var r rune
+		r, n = utf8.DecodeRuneInString(s[i:])
}

diff {
-				fp += fmt.Sprintf("\\x%02x", uint8(*(s - 1)))
+				fp += fmt.Sprintf("\\x%02x", s[i])
}
diff {
-			obj.Fmtrune((*obj.Fmt)(fp), '\\')
-			obj.Fmtrune((*obj.Fmt)(fp), int(r))
+			fp += `\` + string(r)
}
diff {
-			obj.Fmtrune((*obj.Fmt)(fp), int(r))
+			fp += string(r)
}
diff {
-func symfmt(s *Sym) string {
+func symfmt(s *Sym, flag int) string {
}
diff {
-func typefmt(t *Type) string {
+func typefmt(t *Type, flag int) string {
}
diff {
-	r = int(symfmt((*Sym)(fp), s))
+	_ = r
+	str := symfmt(s, flag)
	flag = sf
	fmtmode = sm
-	return string(r)
+	return str
}
diff {
-	r = int(typefmt((*Type)(fp), t))
+	_ = r
+	str := typefmt(t, flag)

	if fmtmode == FTypeId && (sf&obj.FmtUnsigned != 0) {
		fmtpkgpfx--
	}

	flag = sf
	fmtmode = sm
	t.Trecur--
-	return string(r)
+	return str
}
diff {
-	r = -1
+	_ = r
+	var str string
	switch fmtmode {
	case FErr,
		FExp:
-		r = int(nodefmt((*Node)(fp), n))
+		str = nodefmt(n, flag)

	case FDbg:
		dumpdepth++
-		r = int(nodedump((*Node)(fp), n))
+		str = nodedump(n, flag)
		dumpdepth--

	default:
		Fatal("unhandled %N mode")
	}

	flag = sf
	fmtmode = sm
-	return string(r)
+	return str
}
diff {
-	r = 0
+	_ = r
	sep = "; "
}
diff {
	for ; l != nil; l = l.Next {
		fp += fmt.Sprintf("%v", Nconv(l.N, 0))
-		r += 0
		if l.Next != nil {
			fp += sep
-			r += 0
		}
	}

	flag = sf
	fmtmode = sm
-	return string(r)
+	return fp
}
diff {
		// skip leading "type." in method name
-		p = main.Utfrrune(s.Name, '.')
-
-		if p != "" {
-			p = p[1:]
-		} else {
-			p = s.Name
-		}
+		p = s.Name
+		if i := strings.LastIndex(s.Name, "."); i >= 0 {
+			p = s.Name[i+1:]
+		}
}
diff {
-func nodefmt(n *Node) string {
+func nodefmt(n *Node, flag int) string {
}
diff {
-		return stmtfmt((*Node)(f), n)
+		return stmtfmt(n)
}
diff {
-func nodedump(n *Node) string {
+func nodedump(n *Node, flag int) string {
}
diff {
-		return obj.Linksymfmt((*obj.LSym)(fp))
+		panic("linksymfmt")
}
diff {
-	var sf uint32
+	var sf int
}
diff {
-func setfmode(flags *uint32) int {
+func setfmode(flags *int) int {
}
diff {
-var fmtmode int
+var fmtmode int = FErr
}
delete fmtinstallgo
rename arch Thearch
diff {
-		md5write(d, tmp[:], 56-len%64)
+		md5write(d, tmp[:], int(56-len%64))
}
diff {
-		md5write(d, tmp[:], 64+56-len%64)
+		md5write(d, tmp[:], int(64+56-len%64))
}
diff {
func dumpobj() {
	var externs *NodeList
	var tmp *NodeList
-	var arhdr string
+	var arhdr [ArhdrSize]byte
}
diff {
-obj.Memset(arhdr, 0, sizeof(arhdr))
+arhdr = [ArhdrSize]byte{}
}
diff {
-obj.Memset(arhdr, 0, ArhdrSize)
+arhdr = [ArhdrSize]byte{}
}
diff {
-		formathdr(arhdr, "__.PKGDEF", size)
+		formathdr(arhdr[:], "__.PKGDEF", size)
}
diff {
-obj.Bwrite(bout, arhdr, ArhdrSize)
+obj.Bwrite(bout, arhdr[:])
}
diff {
-obj.Bwrite(bout, arhdr, sizeof(arhdr))
+obj.Bwrite(bout, arhdr[:])
}
diff {
-		formathdr(arhdr, namebuf, size)
+		formathdr(arhdr[:], namebuf, size)
}
func formathdr(arhdr []byte, name string, size int64) {
	copy(arhdr[:], fmt.Sprintf("%-16s%-12d%-6d%-6d%-8o%-10d`\n", name, 0, 0, 0, 0644, size))
}
diff {
-	obj.Memmove(p.To.U.Sval, t, n)
+	p.To.U.Sval = t
}
diff {
-	lit = (*Strlit)(make([]byte, sizeof(*lit)+n))
+	lit = new(Strlit)
}
diff {
-
-		obj.Memmove(tmp.lit.S, s, len)
-		tmp.lit.S[len] = '\x00'
+		tmp.lit.S = s
}
func Bputname(b *obj.Biobuf, s *obj.LSym) {
	obj.Bwritestring(b, s.Name)
	obj.Bputc(b, 0)
}
diff {
-var pragcgobuf obj.Fmt
+var pragcgobuf string
}
diff {
-	if pragcgobuf.To > pragcgobuf.Start {
+	if pragcgobuf != "" {
}
diff {
-fmt.Fprintf(bout, "go object %s %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion(), obj.Expstring())
+fmt.Fprintf(bout, "go object %s %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion(), obj.Expstring())
}
diff {
-	bout = obj.Bopen(outfile, obj.OWRITE)
-	if bout == nil {
+	var err error
+	bout, err = obj.Bopenw(outfile)
+	if err != nil {
}
diff {
-obj.Bwrite(bout, "!<arch>\n", 8)
+obj.Bwritestring(bout, "!<arch>\n")
}
diff {
-	obj.Writeobj(Ctxt, bout)
+	obj.Writeobjdirect(Ctxt, bout)
}

export nod
bool yy_isdigit.return
bool yy_isspace.return
bool yy_isalpha.return
bool yy_isalnum.return
bool nacl
bool isfrog.return
bool more.return

diff {
- obj.Isalnum(c) != 0
+ isalnum(c)
}
diff {
- obj.Isdigit(c) != 0
+ isdigit(c)
}
diff {
-obj.Exits("usage")
+os.Exit(2)
}
diff {
-func Gcmain(argc int, argv [XXX]string) int {
+func Main() {
}
diff {
-	for i = 0; i < main.BITS; i++ {
+	for i = 0; i < BITS; i++ {
}
diff {
-	obj.Signal(obj.SIGBUS, fault)
}
diff {
-	obj.Signal(obj.SIGSEGV, fault)
}
diff {
-	obj.Notify(catcher)
}
diff {
-	// Tell the FPU to handle all exceptions.
-	obj.Setfcr(obj.FPPDBL | obj.FPRNR)
}
diff {
-	p = Getgoarch()
+	p = obj.Getgoarch()
}
diff {
-	obj.Binit(&bstdout, 1, obj.OWRITE)
+	bstdout = *obj.Binitw(os.Stdout)
}
diff {
-	goroot = obj.Getgoroot()
-	goos = obj.Getgoos()
+	goroot = obj.Getgoroot()
+	goos = obj.Getgoos()
}
diff {
-	pragcgobuf = ""
}
diff {
-	obj.Quotefmtinstall()
}

export getgoarm
diff {
-	obj.Flagparse(&argc, (**string)(&argv), usage)
+	obj.Flagparse(usage)
}
diff {
-		var f [100]string
-		var i int
		var j int
-		var nf int
-
-		nf = obj.Getfields(debugstr, (*string)(f), 1, int(","))
+		f := strings.Split(debugstr, ",")
-		for i = 0; i < nf; i++ {
+		for i := range f {
+			if f[i] == "" {
+				continue
+			}
}
diff {
-	fmtinstallgo()
}
diff {
-	for i = 0; i < argc; i++ {
-		infile = argv[i]
+	for _, infile = range flag.Args() {
}
diff {
-		curio.bin = obj.Bopen(infile, obj.OREAD)
-		if curio.bin == nil {
+		var err error
+		curio.bin, err = obj.Bopenr(infile)
+		if err != nil {
}
diff {
-	obj.Exits("")
-	return 0
}
delete catcher
diff {
-	if argc < 1 {
+	if flag.NArg() < 1 {
		usage()
}
diff {
-	obj.Exits("")
+	os.Exit(0)
}
diff {
-	obj.Cleanname(q)
+	q = path.Clean(q)
}
diff {
-	obj.Cleanname(cleanbuf)
+	cleanbuf = path.Clean(cleanbuf)
}

func arsize(b *obj.Biobuf, name string) int {
	var buf [ArhdrSize]byte
	if _, err := io.ReadFull(b, buf[:]); err != nil {
		return -1
	}
	aname := strings.Trim(string(buf[0:16]), " ")
	if !strings.HasPrefix(aname, name) {
		return -1
	}
	asize := strings.Trim(string(buf[48:58]), " ")
	i, _ := strconv.Atoi(asize)
	return i
}
diff {
-	p = obj.Brdline(b, '\n').(string)
+	p = obj.Brdline(b, '\n')
}
diff {
-	if obj.Memcmp(p, "!<arch>\n", 8) != 0 {
+	if p != "!<arch>\n" {
}
diff {
-		cleanbuf = string(make([]byte, obj.Strlen(prefix)+obj.Strlen(path_.S)+2))
}
diff {
-	q = string(make([]byte, len(name.S)+1))
-
-	obj.Memmove(q, name.S, len(name.S))
-	q[len(name.S)] = '\x00'
-	q = path.Clean(q)
-	if len(q) != len(name.S) || obj.Memcmp(q, name.S, len(name.S)) != 0 {
+	_ = q
+	if path.Clean(name.S) != name.S {
}
diff {
-	imp = obj.Bopen(namebuf, obj.OREAD)
-	if imp == nil {
+	var err error
+	imp, err = obj.Bopenr(namebuf)
+	if err != nil {
}
diff {
-		if p+10 != q {
+		if p[10:] != q {
}
diff {
-	if c >= main.Runeself {
+	if c >= utf8.RuneSelf {
}
diff {
-	cp = lexbuf
+	cp = &lexbuf
+	cp.Reset()
}
diff {
-	ep = lexbuf[sizeof(lexbuf):]
}
diff {
-			cp[0] = byte(c)
-			cp = cp[1:]
+			cp.WriteByte(byte(c))
}
diff {
-		lexbuf = "\"<string>\""
+		lexbuf.Reset()
+		lexbuf.WriteString(`"<string>"`)
}
diff {
-		lexbuf = "`<string>`"
+		lexbuf.Reset()
+		lexbuf.WriteString("`<string>`")
}
diff {
-		cp = string(make([]byte, 8))
-		clen = sizeof(int32)
-		ncp = 8
+		cp = &strbuf
+		cp.Reset()
}
diff {
-			if v < main.Runeself || escflag != 0 {
+			if v < utf8.RuneSelf || escflag != 0 {
}
diff {
-			if clen+main.UTFmax > ncp {
-				cp = remal(cp, int32(ncp), int32(ncp)).(string)
-				ncp += ncp
-			}
}
diff {
-				cp[clen] = byte(v)
-				clen++
+				cp.WriteByte(byte(v))
}
diff {
-				c = main.Runelen(rune_)
-				main.Runetochar(cp[clen:], &rune_)
-				clen += c
+				cp.WriteRune(rune(rune_))
}

diff {
-			rune_ = uint(c)
-			clen += main.Runetochar(cp[clen:], &rune_)
+			cp.WriteRune(rune(c))
}
diff {
-	*(*int32)(cp) = clen - sizeof(int32) // length
-	for {
-		cp[clen] = 0
-		clen++
-		if !(clen&MAXALIGN != 0) {
-			break
-		}
-	}
-
-	yylval.val.U.Sval = (*Strlit)(cp)
+	yylval.val.U.Sval = &Strlit{S: cp.String()}
}
diff {
-	var cp string
-	var ep string
+	var cp *bytes.Buffer
}
diff {
-var lexbuf string
+var lexbuf bytes.Buffer
+var strbuf bytes.Buffer
+
+func DBG(...interface{}){}
}
diff {
-		if cp[10:] >= ep {
-			Yyerror("identifier too long")
-			errorexit()
-		}
}
diff {
-			if cp[10:] >= ep {
-				Yyerror("identifier too long")
-				errorexit()
-			}
}
diff {
-		cp[0] = byte(c)
-		cp = cp[1:]
+		cp.WriteByte(byte(c))
}
diff {
-	cp = ""
+	cp = nil
}
diff {
-	ep = lexbuf[sizeof(lexbuf)-5:]
}
diff {
-		if cp < ep {
			cp.WriteByte(byte(c))
-		}
}
diff {
-			if !(main.Isalpharune(rune_) != 0) && !(main.Isdigitrune(rune_) != 0) && (importpkg == nil || rune_ != 0xb7) {
+			if !unicode.IsLetter(rune(rune_)) && !unicode.IsDigit(rune(rune_)) && (importpkg == nil || rune_ != 0xb7) {
}
diff {
-			cp = cp[main.Runetochar(cp, &rune_):]
+			cp.WriteRune(rune(rune_))
}
diff {
-	s = Lookup(lexbuf)
+	s = Lookup(lexbuf.String())
}
diff {
-	cp[0] = byte(c)
-	cp = cp[1:]
+	cp.WriteByte(byte(c))
}
diff {
-			if cp == lexbuf[2:] {
+			if lexbuf.Len() == 2 {
}
diff {
-, lexbuf)
+, lexbuf.String())
}
diff {
-	litbuf += lexbuf
+	litbuf += lexbuf.String()
}
diff {
-	var linep string
+	var linep int
	var h *obj.Hist
}
diff {
-	linep = ""
+	linep = 0
	for {
}
diff {
		if c == ':' {
-			linep = cp
+			linep = cp.Len()+1
		}
}
diff {
-		tmp.lit.S = tmp.lit.S[:len]
		tmp.lit.S = s
}
diff {
-func stringsym(s string, len int) *Sym {
+func stringsym(s string) *Sym {
}
diff {
-		off = dsname(sym, off, s[n:], m)
+		off = dsname(sym, off, s[n:n+m])
}
diff {
	// string data
-	for n = 0; n < len; n += m {
+	for n = 0; n < len(s); n += m {
		m = 8
-		if m > len-n {
+		if m > len(s)-n {
-			m = len - n
+			m = len(s) - n
		}
}
diff {
-func dsname(s *Sym, off int, t string, n int) int {
+func dsname(s *Sym, off int, t string) int {
	var p *obj.Prog

	p = Thearch.Gins(obj.ADATA, nil, nil)
	p.From.Type = obj.TYPE_MEM
	p.From.Name = obj.NAME_EXTERN
	p.From.Offset = int64(off)
	p.From.Sym = Linksym(s)
	p.From3.Type = obj.TYPE_CONST
-	p.From3.Offset = int64(n)
+	p.From3.Offset = int64(len(t))

	p.To.Type = obj.TYPE_SCONST
	p.To.U.Sval = t
	return off + n
}
diff {
-func Datastring(s string, len int, a *obj.Addr) {
+func Datastring(s string, a *obj.Addr) {
}
diff {
func Datastring(s string, a *obj.Addr) {
	var sym *Sym

-	sym = stringsym(s, int(len))
+	sym = stringsym(s)
}
diff {
func datagostring(sval *Strlit, a *obj.Addr) {
	var sym *Sym

-	sym = stringsym(sval.S, len(sval.S))
+	sym = stringsym(sval.S)
}
diff {
-	if linep == "" || linep >= ep {
+	if linep == 0 {
		goto out
	}
-	linep[0] = '\x00'
-	linep = linep[1:]
	n = 0
-	for cp = linep; cp[0] != 0; cp = cp[1:] {
+	for _, c := range lexbuf.String()[linep:] {
-		if cp[0] < '0' || cp[0] > '9' {
+		if c < '0' || c > '9' {
			goto out
		}
-		n = n*10 + int(cp[0]) - '0'
+		n = n*10 + int(c) - '0'
}
diff {
	// try to avoid allocating file name over and over
+	name = lexbuf.String()[:linep-1]
	for h = Ctxt.Hist; h != nil; h = h.Link {
-		if h.Name != "" && h.Name == lexbuf {
+		if h.Name != "" && h.Name == name {
			linehist(h.Name, int32(n), 0)
			goto out
		}
	}

-	linehist(lexbuf, int32(n), 0)
+	linehist(name, int32(n), 0)
}
diff {
-	ep = obj.Strchr(lexbuf, ' ')
-	if ep != "" {
-		ep = ""
-	}
+	cmd = lexbuf.String()
+	verb = cmd
+	if i := strings.Index(verb, " "); i >= 0 {
+		verb = verb[:i]
+	}
}
diff {
-	if lexbuf == "go:linkname" {
+	if verb == "go:linkname" {
}
diff {
-	if lexbuf == "go:nointerface" && obj.Fieldtrack_enabled != 0 {
+	if verb == "go:nointerface" && obj.Fieldtrack_enabled != 0 {
}
diff {
-	if lexbuf == "go:noescape" {
+	if verb == "go:noescape" {
}
diff {
-	if lexbuf == "go:nosplit" {
+	if verb == "go:nosplit" {
}
diff {
-	if lexbuf == "go:nowritebarrier" {
+	if verb == "go:nowritebarrier" {
}
diff {
+		f := strings.Fields(cmd)
-		if ep == "" {
+		if len(f) != 3 {
			Yyerror("usage: //go:linkname localname linkname")
			goto out
		}

-		cp = ep[1:]
-		for yy_isspace(int(cp[0])) {
-			cp = cp[1:]
-		}
-		ep = obj.Strchr(cp, ' ')
-		if ep == "" {
-			Yyerror("usage: //go:linkname localname linkname")
-			goto out
-		}
-
-		ep = ""
-		ep = ep[1:]
-		for yy_isspace(int(ep[0])) {
-			ep = ep[1:]
-		}
-		if ep[0] == 0 {
-			Yyerror("usage: //go:linkname localname linkname")
-			goto out
-		}
-
-		Lookup(cp).Linkname = ep
+		Lookup(f[1]).Linkname = f[2]
}

func getimpsym(pp *string) string {
	more(pp) // skip spaces
	p := *pp
	if p == "" || p[0] == '"' {
		return ""
	}
	i := 0
	for i < len(p) && !yy_isspace(int(p[i])) && p[i] != '"' {
		i++
	}
	sym := p[:i]
	*pp = p[i:]
	return sym
}

func getquoted(pp *string) (string, bool) {
	more(pp) // skip spaces
	p := *pp
	if p == "" || p[0] != '"' {
		return "", false
	}
	p = p[1:]
	i := strings.Index(p, `"`)
	if i < 0 {
		return "", false
	}
	*pp = p[i+1:]
	return p[:i], true
}
diff {
-		p = getquoted(&q)
-		if p == "" {
+		var ok bool
+		p, ok = getquoted(&q)
+		if !ok {
}
diff {
-		var ok bool
		p, ok = getquoted(&q)
		if !ok {
			goto err3
}
diff {
	if verb == "cgo_import_dynamic" || verb == "dynimport" {
+		var ok bool
}
diff {
-= obj.BGETC(curio.bin)
+= obj.Bgetc(curio.bin)
}

func getr() int32 {
	var buf [utf8.UTFMax]byte
	
	for i := 0;; i++ {
		c := getc()
		if i == 0 && c < utf8.RuneSelf {
			return int32(c)
		}
		buf[i] = byte(c)
		if i+1 == len(buf) || utf8.FullRune(buf[:i+1]) {
			r, w := utf8.DecodeRune(buf[:i+1])
			if r == utf8.RuneError && w == 1 {
				lineno = lexlineno
				Yyerror("illegal UTF-8 sequence % x", buf[:i+1])
			}
			return int32(r)
		}
	}
}
diff {
-	if u != 0 && (l > main.Runemax || (0xd800 <= l && l < 0xe000)) {
+	if u != 0 && (l > utf8.MaxRune || (0xd800 <= l && l < 0xe000)) {
}
diff {
-		l = main.Runeerror
+		l = utf8.RuneError
}

delete yytinit

diff {
-	elem = obj.Strrchr(path_.S, '/')
-
-	if elem != "" {
-		elem = elem[1:]
-	} else {
-		elem = path_.S
-	}
+	elem = path_.S
+	if i := strings.LastIndex(elem, "/"); i >= 0 {
+		elem = elem[i+1:]
+	}
}
diff {
	if outfile == "" {
-		p = obj.Strrchr(infile, '/')
-		if Ctxt.Windows != 0 {
-			q = obj.Strrchr(infile, '\\')
-			if q > p {
-				p = q
-			}
-		}
-
-		if p == "" {
-			p = infile
-		} else {
-			p = p[1:]
-		}
+		p = infile
+		if i := strings.LastIndex(p, "/"); i >= 0 {
+			p = p[i+1:]
+		}
+		if Ctxt.Windows != 0 {
+			if i := strings.LastIndex(p, `\`); i >= 0 {
+				p = p[i+1:]
+			}
+		}
-		namebuf = fmt.Sprintf("%s", p)
-		p = obj.Strrchr(namebuf, '.')
-		if p != "" {
-			p = ""
-		}
+		namebuf = p
+		if i := strings.LastIndex(namebuf, "."); i >= 0 {
+			namebuf = namebuf[:i]
+		}
}
diff {
-	yytinit()
+	// TODO(rsc): Restore yytinit?
}
diff {
-	cp[0] = 'g'
-	cp = cp[1:] // already read
+	cp.WriteByte('g') // already read
}
diff {
-		if c == EOF || c >= main.Runeself {
+		if c == EOF || c >= utf8.RuneSelf {
}
diff {
-		pragcgo(lexbuf)
+		pragcgo(lexbuf.String())
}
diff {
-	for q = text; q[0] != '\x00' && q[0] != ' '; q = q[1:] {
-	}
-	if q[0] == ' ' {
-		q[0] = '\x00'
-		q = q[1:]
-	}
+	if i := strings.Index(text, " "); i >= 0 {
+		text, q = text[:i], text[i:]
+	}
}
diff {
-	if strings.HasPrefix(lexbuf, "go:cgo_") {
+	if strings.HasPrefix(lexbuf.String(), "go:cgo_") {
}
diff {
-	graph = obj.Calloc(sizeof(*graph)+sizeof(Flow)*nf+size*nf, 1).(*Graph)
-
-	if graph == nil {
-		Fatal("out of memory")
-	}
-	start = (*Flow)(graph + 1)
-	last = nil
-	f = start
-	data = string(f + nf)
-	if size == 0 {
-		data = ""
-	}
+	graph = new(Graph)
+	ff := make([]Flow, nf)
+	start = &ff[0]
}
diff {
+		f := &ff[0]
+		ff = ff[1:]
		p.Opt = f
		f.Prog = p
		if last != nil {
			last.Link = f
		}
		last = f
-		f.Data = data
+		if newData != nil {
+			f.Data = newData()
+		}
		f.Id = int32(id)
-		f++
		id++
-		data = data[size:]
}
diff {
	// Build list of all mergeable variables.
-	var_ = var_[:0]
-
+	nvar = 0
	for l = Curfn.Dcl; l != nil; l = l.Next {
		if canmerge(l.N) {
-			len(var_)++
+			nvar++
		}
	}

-	var_ = obj.Calloc(len(var_)*sizeof(var_[0]), 1).([]TempVar)
-	var_ = var_[:0]
+	var_ = make([]TempVar, nvar)
+	nvar = 0
}

diff {
	// Build list of all mergeable variables.
-	var_ = var_[:0]
-
+	nvar = 0
	for l = Curfn.Dcl; l != nil; l = l.Next {
		if canmerge(l.N) {
-			len(var_)++
+			nvar++
		}
	}

-	var_ = obj.Calloc(len(var_)*sizeof(var_[0]), 1).([]TempVar)
-	var_ = var_[:0]
+	var_ = make([]TempVar, nvar)
+	nvar = 0
	for l = Curfn.Dcl; l != nil; l = l.Next {
}

diff {
-			v = &var_[len(var_)]
-			len(var_)++
+			v = &var_[nvar]
+			nvar++
}
diff {
-func Flowstart(firstp *obj.Prog, size int) *Graph {
+func Flowstart(firstp *obj.Prog, newData func() interface{}) *Graph {
}
diff {
-	g.Rpo = obj.Calloc(g.Num*sizeof(g.Rpo[0]), 1).([]*Flow)
-	idom = obj.Calloc(g.Num*sizeof(idom[0]), 1).([]int32)
-	if g.Rpo == nil || idom == nil {
-		Fatal("out of memory")
-	}
+	g.Rpo = make([]*Flow, g.Num)
+	idom = make([]int32, g.Num)
}
diff {
-Flowstart(firstp, 0)
+Flowstart(firstp, nil)
}
diff {
-	for z = 0; z < main.BITS; z++ {
+	for z = 0; z < BITS; z++ {
}
diff {
-	if nreg == 64 {
-		mask = ^0 // can't rely on C to shift by 64
-	} else {
-		mask = (1 << uint(nreg)) - 1
-	}
+	mask = (1 << uint(nreg)) - 1
}
diff {
-	if nvar >= main.NVAR {
+	if nvar >= NVAR {
}
diff {
+func LOAD(r *Reg, z int) uint64 {
+	return ^r.refbehind.b[z] & r.refahead.b[z]
+}
+
+func STORE(r *Reg, z int) uint64 {
+	return ^r.calbehind.b[z] & r.calahead.b[z]
+}
+
func paint1(f *Flow, bn int) {
}

diff {
-	if LOAD(r)&^(r.set.b[z]&^(r.use1.b[z]|r.use2.b[z]))&bb != 0 {
+	if LOAD(r, z)&^(r.set.b[z]&^(r.use1.b[z]|r.use2.b[z]))&bb != 0 {
}
diff {
-		if STORE(r)&r.regdiff.b[z]&bb != 0 {
+		if STORE(r, z)&r.regdiff.b[z]&bb != 0 {
}
diff {
-		obj.Fmtinstall('Q', Qconv)
}

slice Arch.regnames.return
slice regopt.regnames
diff {
-	g = Flowstart(firstp, sizeof(Reg))
+	g = Flowstart(firstp, func()interface{}{return new(Reg)})
}
diff {
-			bit.b[z] = LOAD(r) &^ (r.act.b[z] | addrs.b[z])
+			bit.b[z] = LOAD(r, z) &^ (r.act.b[z] | addrs.b[z])
}
diff {
-	s = path_.S
-	for s[0] != 0 {
-		s = s[main.Chartorune(&r, s):]
+	_ = s
+	_ = r
+	for _, r := range path_.S {
-		if r == main.Runeerror {
+		if r == utf8.RuneError {
}
diff {
func tostr(v Val) Val {
	var rune_ uint
-	var l int
}
diff {
func Zconv(sp *Strlit, flag int) string {
	var fp string
-
	var s string
-	var se string
}
diff {
func Main() {
-	var i int
}
diff {
func _yylex() int32 {
	var c int
	var c1 int
-	var clen int
	var escflag int
-	var ncp int
}
diff {
func mkpackage(pkgname string) {
	var s *Sym
	var h int32
	var p string
-	var q string
}
diff {
func Flowstart(firstp *obj.Prog, newData func() interface{}) *Graph {
	var id int
	var nf int
	var f *Flow
	var f1 *Flow
	var start *Flow
	var last *Flow
	var graph *Graph
	var p *obj.Prog
	var info ProgInfo
-	var data string
}
diff {
func Yyerror(fmt_ string, args ...interface{}) {
	var i int
-	var buf string
-	var p string
}

export warn
diff {
func Warn(fmt_ string, args ...interface{}) {
-	var arg []interface{}
}

diff {
-	var nhash uint32
	var autohash [101]*Node
}
diff {
func bvcmp(bv1 *Bvec, bv2 *Bvec) int {
-	var nbytes uint32
-
	if bv1.n != bv2.n {
		Fatal("bvequal: lengths %d and %d are not equal", bv1.n, bv2.n)
	}
-	nbytes = bvsize(uint32(bv1.n))
}
diff {
		goto none

+	memcase:
+		fallthrough
+
	case obj.TYPE_MEM:
-	memcase:
}
diff {
func getlinepragma() int {
+	var cmd, verb, name string
}

export Arch
export ostats
export Optstats

slice regnames.return

diff {
-	x86.Listinit6()
}
diff {
-	gc.Gcmain(argc, [XXX]string(argv))
+	gc.Main()
}
diff {
-func main(argc int, argv *string) {
+func main() {
}
diff {
-	gc.Typedef{0, 0, 0},
}
diff {
-// Matches real RtoB but can be used in global initializer.
-const (
+var (
}
diff {
-	LeftRdwr  = gc.LeftRead | gc.LeftWrite
-	RightRdwr = gc.RightRead | gc.RightWrite
+	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
+	RightRdwr uint32 = gc.RightRead | gc.RightWrite
}

bool bgen.true

diff {
-	Bgen           func(*Node, int, int, *obj.Prog)
+	Bgen           func(*Node, bool, int, *obj.Prog)
}

bool complexbool.true

diff {
-		Thearch.Bgen(cmp, 1, -1, p2)
+		Thearch.Bgen(cmp, true, -1, p2)
}
diff {
-		Thearch.Bgen(n.Ntest, 0, -1, breakpc) //		if(!test) goto break
+		Thearch.Bgen(n.Ntest, false, -1, breakpc) //		if(!test) goto break
}
diff {
-		Thearch.Bgen(n.Ntest, 0, int(-n.Likely), p2) //		if(!test) goto p2
+		Thearch.Bgen(n.Ntest, false, int(-n.Likely), p2) //		if(!test) goto p2
}
diff {
-	Thearch.Bgen(&na, bool2int(true_), likely, to)
+	Thearch.Bgen(&na, true_, likely, to)
}

diff {
-func _yylex() int32 {
+func _yylex(yylval *yySymType) int32 {
}
diff {
+type yy struct{}
+
+var yymsg []struct{yystate, yychar int; msg string}
+
+func (yy) Lex(v *yySymType) int {
+	return int(yylex(v))
+}
+
+func (yy) Error(msg string) {
+	Yyerror("%s", msg)
+}
+
+func yyparse() {
+	yyParse(yy{})
+}
+
-func yylex() int32 {
+func yylex(yylval *yySymType) int32 {
}
diff {
-	lx = int(_yylex())
+	lx = int(_yylex(yylval))
}

bool isblanksym.return
func isblanksym(s *Sym) bool {
	return s != nil && s.Name == "_"
}

bool isblank.return
bool isbadimport.return
bool noescape
bool nointerface
bool isptr.return
bool Io.importsafe
bool Pkg.safe
bool Node.noescape
bool Node.nosplit
bool Node.nowritebarrier
bool nosplit
bool nowritebarrier
bool Node.nointerface
bool eqtype.return
bool addmethod.local
bool addmethod.nointerface

diff {
-		c = int(p[0])
-		p = p[1:]
+		c, p = intstarstringplusplus(p)
}
diff {
-	c = int(s[0])
-	s = s[1:]
+	c, s = intstarstringplusplus(s)
}
diff {
-		c = int(s[0])
-		s = s[1:]
+		c, s = intstarstringplusplus(s)
}
diff {
-			c = int(s[0])
-			s = s[1:]
+			c, s = intstarstringplusplus(s)
}
diff {
-				c = int(s[0])
-				s = s[1:]
+				c, s = intstarstringplusplus(s)
}
diff {
-	c = int(s[0])
+	c, _ = intstarstringplusplus(s)
}
diff {
-	for i = 0; Thearch.Typedefs[i].Name != ""; i++ {
+	for i = range Thearch.Typedefs {
}
diff {
-		c = int(curio.cp[0]) & 0xff
-		if c != 0 {
+		if len(curio.cp) == 0 {
+			c = 0
+		} else {
+			c = int(curio.cp[0])
}

diff {
-var alive interface{}
-
-var dead interface{}
+var alive interface{} = nil
+var dead interface{} = 1
}
diff {
- v = n.Opt.(*TempVar)
+ v, _ = n.Opt.(*TempVar)
}
diff {
- n = p.From.Node.(*Node)
+ n, _ = p.From.Node.(*Node)
}
diff {
- n = p.To.Node.(*Node)
+ n, _ = p.To.Node.(*Node)
}
diff {
- v.nextinnode = node.Opt.(*Var)
+ v.nextinnode, _ = node.Opt.(*Var)
}
diff {
- v1 = v.node.Opt.(*Var)
+ v1, _ = v.node.Opt.(*Var)
}
diff {
- for v = n.Opt.(*Var); v != nil; v = v.nextinnode {
+ for v, _ = n.Opt.(*Var); v != nil; v = v.nextinnode {
}

func more(pp *string) bool {
	p := *pp
	for p != "" && yy_isspace(int(p[0])) {
		p = p[1:]
	}
	*pp = p
	return p != ""
}

diff {
-				pos = int32(int(((from.Node).(*Node)).Opt.(uint32))) - 1 // index in vars
-				if pos == -1 {
+				pos, ok := from.Node.(*Node).Opt.(int32) // index in vars
+				if !ok {
}
diff {
-				pos = int32(int(((to.Node).(*Node)).Opt.(uint32))) - 1 // index in vars
-				if pos == -1 {
+				pos, ok := to.Node.(*Node).Opt.(int32) // index in vars
+				if !ok {
}
diff {
-	ll.N.Opt = interface{}(uint32(len(result) + 1))
+	ll.N.Opt = int32(len(result))
}

diff {
func progeffects(prog *obj.Prog, vars []*Node, uevar *Bvec, varkill *Bvec, avarinit *Bvec) {
	var info ProgInfo
	var from *obj.Addr
	var to *obj.Addr
	var node *Node
	var i int32
-	var pos int32
}

diff {
-	node = a.Node.(*Node)
+	node, _ = a.Node.(*Node)
}

bool haspointers.return

delete Strlit.len

diff {
-	if len > 100 {
+	if len(s) > 100 {
		// huge strings are made static to avoid long names
}
diff {
	// string header
	off = dsymptr(sym, off, sym, Widthptr+Widthint)
-
-	off = duintxx(sym, off, uint64(len), Widthint)
+	off = duintxx(sym, off, uint64(len(s)), Widthint)
}

string Strlit.s Strlit.len

diff {
-				l2 = l1
-				len = 0
-				for l2 != nil && Isconst(l2.N, CTSTR) {
-					nr = l2.N
-					len += len(nr.Val.U.Sval.S)
-					l2 = l2.Next
-				}
-
				// merge from l1 up to but not including l2
-				str = (*Strlit)(make([]byte, sizeof(*str)+len))
-
+				str = new(Strlit)
-				str.S = str.S[:len]
-				len = 0
				l2 = l1
				for l2 != nil && Isconst(l2.N, CTSTR) {
					nr = l2.N
					str.S += nr.Val.U.Sval.S
-					len += len(nr.Val.U.Sval.S)
					l2 = l2.Next
				}
}
diff {
-	Datastring(str, len(str)+1, &p.To)
+	Datastring(str+"\x00", &p.To) // TODO(rsc): Remove NUL
}
diff {
-	Datastring(sval.S, len(sval.S), &p.To)
+	Datastring(sval.S, &p.To)
}
diff {
	p.To.U.Sval = t
-	return off + n
+	return off + len(t)
}
diff {
-		if len(p.Path.S) == len(path_.S) && obj.Memcmp(path_.S, p.Path.S, len(path_.S)) == 0 {
+		if p.Path.S == path_.S {
}
diff {
-	var len int32
	var str *Strlit
}
diff {
-			gc.Datastring(nl.Val.U.Sval.S, len(nl.Val.U.Sval.S), &p1.From)
+			gc.Datastring(nl.Val.U.Sval.S, &p1.From)
}
diff {
-		linehist("", 0, 0)
+		linehist("<pop>", 0, 0)
}

diff {
- fmt.Sprintf("$\"%q\"", a.U.Sval)
+ fmt.Sprintf("$%q", a.U.Sval)
}
diff {
-	if s.Name != "" && s.Name[0] == '_' && s.Name[1] == '\x00' {
+	if s.Name == "_" {
}
diff {
- mphextofix(&a.Val, start)
+ mphextofix(&a.Val, start[:len(start)-len(s)])
}
diff {
		case '0':
-			if s[0] == 'x' {
+			if s != "" && s[0] == 'x' {
				base = 16
}
diff {
	for base == -1 {
+		if s == "" {
+			base = 10
+			break
+		}
-		tmp8 := s
+		c := s[0]
		s = s[1:]
-		switch tmp8[0] {
+		switch c {
}

export eqtype noconv

diff {
-		gmove(ncon(-1), &t1)
+		gmove(ncon(^uint32(0)), &t1)
}

export mpmovecfix
export expandpkg

diff {
-	arm.Listinit5()
}
diff {
-	i386.Listinit8()
}
diff {
-	ppc64.Listinit9()
}

export mpmovecflt
export use_sse

diff {
-				obj.Memmove(&varianttable[varianttable[i][j]], &varianttable[i], sizeof(varianttable[i]))
+				varianttable[varianttable[i][j]] = varianttable[i]
}
diff {
-			gins(i386.ACMPL, &t1, ncon(-0x80))
+			gins(i386.ACMPL, &t1, ncon(-0x80 & (1<<32-1)))
}
diff {
-			gmove(ncon(-0x80), &t1)
+			gmove(ncon(-0x80 & (1<<32-1)), &t1)
}

func memname(n *gc.Node, t *gc.Type) {
	gc.Tempname(n, t)
	n.Sym = gc.Lookup("."+n.Sym.Name[1:]) // keep optimizer from registerizing
	n.Orig.Sym = n.Sym
}

export OptStats

bool btest.return
bool Node.needctxt
bool convlit1.explicit
bool isconst.return
bool overlap.return
bool variter.doexpr
bool colasname.return
bool Type.nointerface
bool EscState.recursive
bool analyze.recursive
bool escwalk.leaks
bool initname.return
bool exportedsym.return
bool stmtfmt.simpleinit
bool stmtfmt.complexinit
bool stmtfmt.extrablock
bool exprfmt.ptrlit
bool nodedump.recur
bool ismem.return
bool ishairy.return
bool mkinlcall1.chkargcount
bool mkinlcall1.variadic
bool istemp.return
bool isaddrokay.return
bool ismulticall.return
bool ordertemp.clear
bool orderexpr.hasbyte
bool orderexpr.haslit
bool isnewselect.return
bool isselectgocall.return
bool isdeferreturn.return
bool issafepoint.return
bool doms.return
bool canmerge.return
bool isforkfunc.return
bool haspointers.ret
bool usegcprog.return
bool gengcmask.half
bool iszero.return
bool isvaluelit.return
bool ispaddedfield.return
bool istype.return
bool isfixedarray.return
bool isslice.return
bool isinter.return
bool isnilinter.return
bool isideal.return
bool noconv.return
bool isdirectiface.return
bool casebody.needvar
bool nodbool.b
bool callrecv.return
bool samesafeexpr.return
bool isterminating.return
bool samelist.return
bool walkprint.notfirst
bool varexpr.return
bool vmatch2.return
bool sliceany.slice3
bool samecheap.return
bool bounded.return

delete ldobjfile readsym rdint rdstring rddata rdsym addlibpath addlib

export lookup

diff {
-	t.Haspointers = 1 + ret
+	t.Haspointers = 1 + uint8(bool2int(ret))
}

func blockany(bb *BasicBlock, f func(*obj.Prog) bool) bool {
	for p := bb.last; p != nil; p = p.Opt.(*obj.Prog) {
		if f(p) {
			return true
		}
	}
	return false
}

diff {
-			hasbyte |= l.N.Op == OARRAYBYTESTR
-			haslit |= l.N.Op == OLITERAL && len(l.N.Val.U.Sval.S) != 0
+			hasbyte = hasbyte || l.N.Op == OARRAYBYTESTR
+			haslit = haslit || l.N.Op == OLITERAL && len(l.N.Val.U.Sval.S) != 0
}

bool isselectcommcasecall.return
bool blockany.return
bool isgoconst.return isifacemethod.return ishairylist.return islive.return ispkgin.return isartificial.return isreflexive.return isliteral.return isnil.return isptrto.return iscomptype.return islvalue.return isunsafebuiltin.return isstack.return isglobal.return
bool hascallchan.return hasddd.return
bool candiscard.return candiscardlist.return
bool isbranch.return isdconst.return isfloatreg.return
bool nokeys.return canuselocaltls.return nofollow.return isint32.return isuint32.return isextern.return isax.return nochange.return
bool smallintconst.return isfat.return noreturn.return is64.return 
bool bany.return
bool bvisempty.return
bool doesoverflow.return
bool complexop.return
bool dflag.return
bool stmtwithinit.return
bool samereg.return
bool anyinit.return
bool skiptopkgdef.return
bool findpkg.return
bool escchar.return
bool mpiszero.return
bool loophead.return
bool callinstr.return
bool staticcopy.return
bool staticassign.return
bool simplename.return
bool oaslit.return
bool stataddr.return
bool gen_as_init.return
bool onlist.return
bool eqtype1.return
bool eqtypenoname.return
bool subtype.return
bool implements.return
bool callrecvlist.return
bool looktypedot.return
bool lookdot.return
bool prime.return
bool fncall.return
bool needwritebarrier.return
bool aliased.return
bool vmatch1.return
bool flushpool.return
bool pushpop.return
bool getmask.return
bool getmask64.return
bool anyregalloc.return
bool componentgen.return
bool cadable.return
bool samaddr.return
bool dotaddable.return
bool sudoaddable.return
bool subprop.return
bool copy1.return copyprop.return
bool shortprop.return
bool shiftprop.return
bool findu1.return
bool xtramodes.return
bool copyas.return
bool copyau.return
bool predicable.return
bool modifiescpsr.return
bool xgen.return
bool needc.return
bool regtyp.return
bool regconsttyp.return
bool prevl.return

diff {
-	Anyregalloc    func() int
+	Anyregalloc    func() bool
}
diff {
-	Regtyp         func(*obj.Addr) int
+	Regtyp         func(*obj.Addr) bool
}

diff {
-	var wasregalloc int32
}
diff {
-	wasregalloc = int32(Thearch.Anyregalloc())
+	wasregalloc := Thearch.Anyregalloc()
}
diff {
-	if int32(Thearch.Anyregalloc()) != wasregalloc {
+	if Thearch.Anyregalloc() != wasregalloc {
}

bool visit.recursive
bool dcommontype.gcprog
bool staticinit.return
bool Node.bounded

diff {
-		if p.As != obj.ACHECKNIL || !(Thearch.Regtyp(&p.From) != 0) {
+		if p.As != obj.ACHECKNIL || !Thearch.Regtyp(&p.From) {
}

diff {
-		if (info.Flags&RightWrite != 0) && !(Thearch.Regtyp(&p.To) != 0) {
+		if (info.Flags&RightWrite != 0) && !Thearch.Regtyp(&p.To) {
}

bool cgen_shift.bounded
bool agenr.bounded
bool cgenindex.bounded
bool finduse.return
bool copyau1.return
bool stackaddr.return
bool smallindir.return

diff {
-	Sameaddr       func(*obj.Addr, *obj.Addr) int
-	Smallindir     func(*obj.Addr, *obj.Addr) int
-	Stackaddr      func(*obj.Addr) int
+	Sameaddr       func(*obj.Addr, *obj.Addr) bool
+	Smallindir     func(*obj.Addr, *obj.Addr) bool
+	Stackaddr      func(*obj.Addr) bool
}

diff {
-		if Thearch.Stackaddr(&p.From) != 0 {
+		if Thearch.Stackaddr(&p.From) {
}

diff {
-		if (info.Flags&LeftRead != 0) && Thearch.Smallindir(&p.From, &fcheck.Prog.From) != 0 {
+		if (info.Flags&LeftRead != 0) && Thearch.Smallindir(&p.From, &fcheck.Prog.From) {
}

diff {
-		if (info.Flags&(RightRead|RightWrite) != 0) && Thearch.Smallindir(&p.To, &fcheck.Prog.From) != 0 {
+		if (info.Flags&(RightRead|RightWrite) != 0) && Thearch.Smallindir(&p.To, &fcheck.Prog.From) {
}

diff {
-		if (info.Flags&RightWrite != 0) && Thearch.Sameaddr(&p.To, &fcheck.Prog.From) != 0 {
+		if (info.Flags&RightWrite != 0) && Thearch.Sameaddr(&p.To, &fcheck.Prog.From) {
}

diff {
-		if f != fcheck && p.As == obj.ACHECKNIL && Thearch.Sameaddr(&p.From, &fcheck.Prog.From) != 0 {
+		if f != fcheck && p.As == obj.ACHECKNIL && Thearch.Sameaddr(&p.From, &fcheck.Prog.From) {
}

diff {
-		if (info.Flags&RightWrite != 0) && Thearch.Sameaddr(&p.To, &fcheck.Prog.From) != 0 {
+		if (info.Flags&RightWrite != 0) && Thearch.Sameaddr(&p.To, &fcheck.Prog.From) {
}

bool sameaddr.return
bool checkpool.return
bool stacksplit.noctxt
bool agen.bounded
bool bgen_float.true_

diff {
-		p.To.Sym = ctxt.Symmorestack[noctxt]
+		p.To.Sym = ctxt.Symmorestack[bool2int(noctxt)]
}
