package src/liblink/* include/* liblink1
package src/liblink/*5.c src/cmd/5l/*.h liblink1/arm
package src/liblink/*6.c src/cmd/6l/*.h liblink1/amd64
package src/liblink/*8.c src/cmd/8l/*.h liblink1/x86
package src/liblink/*9.c src/cmd/9l/*.h liblink1/ppc64

delete emallocz estrdup erealloc

func expandpkg(t0 string, pkg string) string {
	return strings.Replace(t0, `"".`, pkg+".", -1)
}

func Symgrow(ctxt *Link, s *LSym, lsiz int64) {
	var siz int
	siz = int(lsiz)
	if int64(siz) != lsiz {
		log.Fatal("Symgrow size %d too long", lsiz)
	}
	if len(s.P) >= siz {
		return
	}
	for cap(s.P) < siz {
		s.P = append(s.P[:cap(s.P)], 0)
	}
	s.P = s.P[:siz]
}

func savedata(ctxt *Link, s *LSym, p *Prog, pn string) {
	off := int32(p.From.Offset)
	siz := int32(ctxt.Arch.Datasize(p))
	if off < 0 || siz < 0 || off >= 1<<30 || siz >= 100 {
		mangle(pn)
	}
	if ctxt.Enforce_data_order != 0 && off < int32(len(s.P)) {
		ctxt.Diag("data out of order (already have %d)\n%P", len(s.P), p)
	}
	Symgrow(ctxt, s, int64(off+siz))
	
	switch int(p.To._type) {
	default:
		ctxt.Diag("bad data: %P", p)

	case ctxt.Arch.D_FCONST:
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte floating point constant", siz)
		
		case 4:
			flt := math.Float32bits(float32(p.To.U.Dval))
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], flt)
		
		case 8:
			flt := math.Float64bits(p.To.U.Dval)
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], flt)
		}

	case ctxt.Arch.D_SCONST:
		copy(s.P[off:off+siz], p.To.U.Sval)
	
	case ctxt.Arch.D_CONST, ctxt.Arch.D_ADDR:
		if p.To.Sym != nil || int(p.To._type) == ctxt.Arch.D_ADDR {
			r := Addrel(s)
			r.Off = off
			r.Siz = uint8(siz)
			r.Sym = p.To.Sym
			r._type = R_ADDR
			r.Add = p.To.Offset
			break
		}
		o := p.To.Offset
		switch siz {
		default:
			ctxt.Diag("unexpected %d-byte integer constant", siz)
		case 1:
			s.P[off] = byte(o)
		case 2:
			ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(o))
		case 4:
			ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(o))
		case 8:
			ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(o))
		}
	}	
}

func Addrel(s *LSym) *Reloc {
	s.R = append(s.R, Reloc{})
	return &s.R[len(s.R)-1]
}

func setuintxx(ctxt *Link, s *LSym, off int64, v uint64, wid int64) int64 {
	if s._type == 0 {
		s._type = SDATA
	}
	s.Reachable = 1
	if s.Size < off+wid {
		s.Size = off + wid
		Symgrow(ctxt, s, s.Size)
	}

	switch wid {
	case 1:
		s.P[off] = uint8(v)
	case 2:
		ctxt.Arch.ByteOrder.PutUint16(s.P[off:], uint16(v))
	case 4:
		ctxt.Arch.ByteOrder.PutUint32(s.P[off:], uint32(v))
	case 8:
		ctxt.Arch.ByteOrder.PutUint64(s.P[off:], uint64(v))
	}
	
	return off+wid
}

diff {
type LinkArch struct {
	Name          string
	Thechar       int
	Endian        int32
+	ByteOrder	binary.ByteOrder
}
